// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/tenant.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 登录平台
public enum Api_Core_LoginPlatform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case dashboard // = 0
  case client // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .dashboard
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dashboard
    case 1: self = .client
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dashboard: return 0
    case .client: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_LoginPlatform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_LoginPlatform] = [
    .dashboard,
    .client,
  ]
}

#endif  // swift(>=4.2)

///线路选择
///0客服，1用户，2混合
public enum Api_Core_RoleRoute: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case worker // = 0
  case customer // = 1
  case all // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .worker
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .worker
    case 1: self = .customer
    case 2: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .worker: return 0
    case .customer: return 1
    case .all: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_RoleRoute: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_RoleRoute] = [
    .worker,
    .customer,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// 分页参数
public struct Api_Core_PageParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量
  public var size: UInt32 = 0

  /// 当前页
  public var page: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 角色id
  public var roleID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routeName: String = String()

  public var routeURL: String = String()

  public var routeRole: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routes: [Api_Core_RouteItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_CaptchaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var captchaKey: String = String()

  public var imageBase64: String = String()

  public var thumbBase64: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户名最多16个中文字符（字母、数字、特殊符号中包含两种）（必填）
  public var account: String = String()

  public var password: String = String()

  /// 验证码
  public var captchaDots: String {
    get {return _captchaDots ?? String()}
    set {_captchaDots = newValue}
  }
  /// Returns true if `captchaDots` has been explicitly set.
  public var hasCaptchaDots: Bool {return self._captchaDots != nil}
  /// Clears the value of `captchaDots`. Subsequent reads from it will return its default value.
  public mutating func clearCaptchaDots() {self._captchaDots = nil}

  /// 验证码ID
  public var captchaKey: String {
    get {return _captchaKey ?? String()}
    set {_captchaKey = newValue}
  }
  /// Returns true if `captchaKey` has been explicitly set.
  public var hasCaptchaKey: Bool {return self._captchaKey != nil}
  /// Clears the value of `captchaKey`. Subsequent reads from it will return its default value.
  public mutating func clearCaptchaKey() {self._captchaKey = nil}

  /// 登录平台
  public var loginPlatform: Api_Core_LoginPlatform {
    get {return _loginPlatform ?? .dashboard}
    set {_loginPlatform = newValue}
  }
  /// Returns true if `loginPlatform` has been explicitly set.
  public var hasLoginPlatform: Bool {return self._loginPlatform != nil}
  /// Clears the value of `loginPlatform`. Subsequent reads from it will return its default value.
  public mutating func clearLoginPlatform() {self._loginPlatform = nil}

  /// 设备信息
  public var deviceInfo: Api_Common_DeviceInfo {
    get {return _deviceInfo ?? Api_Common_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {self._deviceInfo = nil}

  /// 起聊版本号
  public var clientVer: String {
    get {return _clientVer ?? String()}
    set {_clientVer = newValue}
  }
  /// Returns true if `clientVer` has been explicitly set.
  public var hasClientVer: Bool {return self._clientVer != nil}
  /// Clears the value of `clientVer`. Subsequent reads from it will return its default value.
  public mutating func clearClientVer() {self._clientVer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _captchaDots: String? = nil
  fileprivate var _captchaKey: String? = nil
  fileprivate var _loginPlatform: Api_Core_LoginPlatform? = nil
  fileprivate var _deviceInfo: Api_Common_DeviceInfo? = nil
  fileprivate var _clientVer: String? = nil
}

public struct Api_Core_LoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  /// 客服信息
  public var items: Api_Common_Worker {
    get {return _items ?? Api_Common_Worker()}
    set {_items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return self._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {self._items = nil}

  /// 过期时间（分）
  public var chatExpireTime: Int32 = 0

  public var bindGl: Bool = false

  /// 第三方API是否开启
  public var thirdApiEnabled: Bool = false

  /// 后台线路
  public var backgroundLine: String = String()

  public var clique: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _items: Api_Common_Worker? = nil
}

public struct Api_Core_LogoutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 登出平台
  public var logoutPlatform: Api_Core_LoginPlatform = .dashboard

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 登录下级账号
public struct Api_Core_ManagerLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_ManagerLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  /// 客服信息, 此处字段名和 LoginResponse 保持一致
  public var items: Api_Common_Worker {
    get {return _items ?? Api_Common_Worker()}
    set {_items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return self._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {self._items = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _items: Api_Common_Worker? = nil
}

public struct Api_Core_TenantCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户名 商户名称最少1位，最多16个字符
  public var name: String = String()

  /// 商户账号 用户名最少3位，最多16个字符
  public var account: String = String()

  /// 密码最少6位最多20个字符，至少包括字母、数字、特殊符号其中两种。
  public var password: String = String()

  /// 客服数量最高9999
  public var workerCapacity: Int32 = 0

  /// 每日接待人数
  public var dailyServiceCapacity: Int32 = 0

  /// 商户分组
  public var cliqueID: Int32 = 0

  /// 线路组id
  public var lineGroupID: Int32 = 0

  /// h5线路
  public var h5Line: String = String()

  /// 后台线路
  public var backgroundLine: String = String()

  /// 备注
  public var remark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_TenantQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var tenantItem: [Api_Core_TenantItem] = []

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_DeleteTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tenantID: UInt32 = 0

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 {
    get {return _storage._tenantID}
    set {_uniqueStorage()._tenantID = newValue}
  }

  /// 商户绑定公钥
  public var tenantPublicKey: String {
    get {return _storage._tenantPublicKey}
    set {_uniqueStorage()._tenantPublicKey = newValue}
  }

  /// 商户名称
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// 最大工作人员数量
  public var workersCapacity: Int32 {
    get {return _storage._workersCapacity}
    set {_uniqueStorage()._workersCapacity = newValue}
  }

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 {
    get {return _storage._dailyServiceCapacity}
    set {_uniqueStorage()._dailyServiceCapacity = newValue}
  }

  /// 入口数量
  public var entranceNum: Int32 {
    get {return _storage._entranceNum}
    set {_uniqueStorage()._entranceNum = newValue}
  }

  /// 用户名(商户账号)
  public var userName: String {
    get {return _storage._userName}
    set {_uniqueStorage()._userName = newValue}
  }

  /// 月均咨询量
  public var averageMonthly: Int32 {
    get {return _storage._averageMonthly}
    set {_uniqueStorage()._averageMonthly = newValue}
  }

  /// 累计咨询量
  public var cumulativeVolume: Int32 {
    get {return _storage._cumulativeVolume}
    set {_uniqueStorage()._cumulativeVolume = newValue}
  }

  /// 商户账号密码
  public var password: String {
    get {return _storage._password}
    set {_uniqueStorage()._password = newValue}
  }

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return _storage._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {_uniqueStorage()._createAt = nil}

  /// 删除时间（依次判断是否已删除）
  public var deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deleteAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deleteAt = newValue}
  }
  /// Returns true if `deleteAt` has been explicitly set.
  public var hasDeleteAt: Bool {return _storage._deleteAt != nil}
  /// Clears the value of `deleteAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteAt() {_uniqueStorage()._deleteAt = nil}

  /// 所在分组名称
  public var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  /// 所在分组名称
  public var cliqueID: Int32 {
    get {return _storage._cliqueID}
    set {_uniqueStorage()._cliqueID = newValue}
  }

  public var apiEnabled: Bool {
    get {return _storage._apiEnabled}
    set {_uniqueStorage()._apiEnabled = newValue}
  }

  public var apiFaqURL: String {
    get {return _storage._apiFaqURL}
    set {_uniqueStorage()._apiFaqURL = newValue}
  }

  public var apiRequestURL: String {
    get {return _storage._apiRequestURL}
    set {_uniqueStorage()._apiRequestURL = newValue}
  }

  public var apiName: String {
    get {return _storage._apiName}
    set {_uniqueStorage()._apiName = newValue}
  }

  public var apiPwd: String {
    get {return _storage._apiPwd}
    set {_uniqueStorage()._apiPwd = newValue}
  }

  public var apiPubKey: String {
    get {return _storage._apiPubKey}
    set {_uniqueStorage()._apiPubKey = newValue}
  }

  /// api充值订单请求url
  public var apiRechargeRequestURL: String {
    get {return _storage._apiRechargeRequestURL}
    set {_uniqueStorage()._apiRechargeRequestURL = newValue}
  }

  /// 线路组id
  public var lineGroupID: Int32 {
    get {return _storage._lineGroupID}
    set {_uniqueStorage()._lineGroupID = newValue}
  }

  /// h5线路
  public var h5Line: String {
    get {return _storage._h5Line}
    set {_uniqueStorage()._h5Line = newValue}
  }

  /// 后台线路
  public var backgroundLine: String {
    get {return _storage._backgroundLine}
    set {_uniqueStorage()._backgroundLine = newValue}
  }

  /// 线路组
  public var lineGroup: Api_Common_TenantsLineGroup {
    get {return _storage._lineGroup ?? Api_Common_TenantsLineGroup()}
    set {_uniqueStorage()._lineGroup = newValue}
  }
  /// Returns true if `lineGroup` has been explicitly set.
  public var hasLineGroup: Bool {return _storage._lineGroup != nil}
  /// Clears the value of `lineGroup`. Subsequent reads from it will return its default value.
  public mutating func clearLineGroup() {_uniqueStorage()._lineGroup = nil}

  /// 修改时间
  public var updateAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateAt = newValue}
  }
  /// Returns true if `updateAt` has been explicitly set.
  public var hasUpdateAt: Bool {return _storage._updateAt != nil}
  /// Clears the value of `updateAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateAt() {_uniqueStorage()._updateAt = nil}

  /// h5域名+证书
  public var h5DomainCert: String {
    get {return _storage._h5DomainCert}
    set {_uniqueStorage()._h5DomainCert = newValue}
  }

  /// 备注
  public var remark: String {
    get {return _storage._remark}
    set {_uniqueStorage()._remark = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Api_Core_AdminLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_AdminLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: 修改商户登录账号和密码
public struct Api_Core_UpdateTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  /// 商户名称
  public var name: String = String()

  /// 客服数量
  public var workerCapacity: Int32 = 0

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 = 0

  /// 商户账号密码(密码调整)
  public var password: String = String()

  /// 商户分组
  public var cliqueID: Int32 = 0

  /// 商户云信前缀
  public var nimprex: String = String()

  /// 线路组id
  public var lineGroupID: Int32 = 0

  /// h5线路
  public var h5Line: String = String()

  /// 后台线路
  public var backgroundLine: String = String()

  /// 备注
  public var remark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_PublicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///key
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryTenantInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Api_Core_TenantItem {
    get {return _item ?? Api_Core_TenantItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Api_Core_TenantItem? = nil
}

/// TODO: 更新云信信息
public struct Api_Core_UpdateNimInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var nimid: String = String()

  public var nimsession: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: 更新云信信息
public struct Api_Core_VersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 {
    get {return _versionID ?? 0}
    set {_versionID = newValue}
  }
  /// Returns true if `versionID` has been explicitly set.
  public var hasVersionID: Bool {return self._versionID != nil}
  /// Clears the value of `versionID`. Subsequent reads from it will return its default value.
  public mutating func clearVersionID() {self._versionID = nil}

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  public var status: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _versionID: Int32? = nil
}

public struct Api_Core_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return self._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {self._createAt = nil}

  /// 更新时间
  public var updateAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateAt = newValue}
  }
  /// Returns true if `updateAt` has been explicitly set.
  public var hasUpdateAt: Bool {return self._updateAt != nil}
  /// Clears the value of `updateAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateAt() {self._updateAt = nil}

  public var status: Int32 = 0

  public var `operator`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_CreateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_UpdateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: Int32 = 0

  public var optype: Api_Common_OperationsType = .operationTypeUnknown

  public var softname: String = String()

  public var majorVersion: String = String()

  public var minerVersion: String = String()

  public var force: Bool = false

  public var downloadURL: String = String()

  public var plistURL: String = String()

  public var remark: String = String()

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return self._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {self._createAt = nil}

  /// 更新时间
  public var updateAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateAt = newValue}
  }
  /// Returns true if `updateAt` has been explicitly set.
  public var hasUpdateAt: Bool {return self._updateAt != nil}
  /// Clears the value of `updateAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateAt() {self._updateAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_GetVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分配一线客服
  public var list: [Api_Core_VersionResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantThirdSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  public var apiRequestURL: String = String()

  public var apiName: String = String()

  public var apiPwd: String = String()

  public var apiPubKey: String = String()

  /// api充值订单请求url
  public var apiRechargeRequestURL: String = String()

  public var apiEnabled: Bool = false

  public var apiFaqURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 线路组列表请求参数
public struct Api_Core_LineGroupListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// 线路组名称
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// 删除状态
  public var disableStatus: CommonDisableStatus {
    get {return _disableStatus ?? .default}
    set {_disableStatus = newValue}
  }
  /// Returns true if `disableStatus` has been explicitly set.
  public var hasDisableStatus: Bool {return self._disableStatus != nil}
  /// Clears the value of `disableStatus`. Subsequent reads from it will return its default value.
  public mutating func clearDisableStatus() {self._disableStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
  fileprivate var _name: String? = nil
  fileprivate var _disableStatus: CommonDisableStatus? = nil
}

/// 线路组列表响应参数
public struct Api_Core_LineGroupListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// 线路组列表
  public var list: [Api_Common_TenantsLineGroup] = []

  /// 总数
  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

/// 线路组创建请求参数
public struct Api_Core_LineGroupCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 线路组名称
  public var name: String = String()

  /// H5线路
  public var h5Lines: CommonListString {
    get {return _h5Lines ?? CommonListString()}
    set {_h5Lines = newValue}
  }
  /// Returns true if `h5Lines` has been explicitly set.
  public var hasH5Lines: Bool {return self._h5Lines != nil}
  /// Clears the value of `h5Lines`. Subsequent reads from it will return its default value.
  public mutating func clearH5Lines() {self._h5Lines = nil}

  /// 后台线路
  public var backgroundLines: CommonListString {
    get {return _backgroundLines ?? CommonListString()}
    set {_backgroundLines = newValue}
  }
  /// Returns true if `backgroundLines` has been explicitly set.
  public var hasBackgroundLines: Bool {return self._backgroundLines != nil}
  /// Clears the value of `backgroundLines`. Subsequent reads from it will return its default value.
  public mutating func clearBackgroundLines() {self._backgroundLines = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _h5Lines: CommonListString? = nil
  fileprivate var _backgroundLines: CommonListString? = nil
}

/// 线路组更新请求参数
public struct Api_Core_LineGroupUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 线路组id
  public var id: Int32 = 0

  /// 线路组名称
  public var name: String = String()

  /// H5线路
  public var h5Lines: CommonListString {
    get {return _h5Lines ?? CommonListString()}
    set {_h5Lines = newValue}
  }
  /// Returns true if `h5Lines` has been explicitly set.
  public var hasH5Lines: Bool {return self._h5Lines != nil}
  /// Clears the value of `h5Lines`. Subsequent reads from it will return its default value.
  public mutating func clearH5Lines() {self._h5Lines = nil}

  /// 后台线路
  public var backgroundLines: CommonListString {
    get {return _backgroundLines ?? CommonListString()}
    set {_backgroundLines = newValue}
  }
  /// Returns true if `backgroundLines` has been explicitly set.
  public var hasBackgroundLines: Bool {return self._backgroundLines != nil}
  /// Clears the value of `backgroundLines`. Subsequent reads from it will return its default value.
  public mutating func clearBackgroundLines() {self._backgroundLines = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _h5Lines: CommonListString? = nil
  fileprivate var _backgroundLines: CommonListString? = nil
}

/// 线路组删除请求参数
public struct Api_Core_LineGroupDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 线路组id
  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户查询客服请求参数
public struct Api_Core_TenantWorkerQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var tenantID: Int32 = 0

  public var name: String = String()

  public var workerState: Api_Common_WorkerState = .workerOffline

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

/// 商户查询客服响应
public struct Api_Core_TenantWorkerQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Api_Core_WorkerWithState] = []

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// 分页客服数量
  public var total: Int32 = 0

  /// 在线客服数量
  public var onlineTotal: Int32 = 0

  /// 总客服数量
  public var allTotal: Int32 = 0

  /// 最大工作人员数量
  public var workersCapacity: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_WorkerWithState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var worker: Api_Common_Worker {
    get {return _worker ?? Api_Common_Worker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  public var workerState: Api_Common_WorkerState = .workerOffline

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _worker: Api_Common_Worker? = nil
}

public struct Api_Core_TenantLogReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var queryType: Int32 = 0

  public var userName: String = String()

  public var role: Int32 = 0

  public var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  public var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  public mutating func clearIp() {self._ip = nil}

  public var date: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
  fileprivate var _ip: String? = nil
}

public struct Api_Core_TenantLogItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var userID: Int32 = 0

  public var userAccount: String = String()

  public var role: String = String()

  public var createTime: Int64 = 0

  public var detail: String = String()

  public var ip: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantLogResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var logs: [Api_Core_TenantLogItem] = []

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

/// 商户后台路由列表请求参数
public struct Api_Core_TenantRouteListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// name
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// url
  public var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  /// pid
  public var pid: Int32 {
    get {return _pid ?? 0}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  public var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  public mutating func clearPid() {self._pid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
  fileprivate var _name: String? = nil
  fileprivate var _url: String? = nil
  fileprivate var _pid: Int32? = nil
}

/// 商户后台路由列表返回参数
public struct Api_Core_TenantRouteListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// list
  public var list: [Api_Common_TenantRoute] = []

  /// 总数
  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
}

/// 商户后台路由创建请求参数
public struct Api_Core_TenantRouteCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name
  public var name: String = String()

  /// url
  public var url: String = String()

  /// pid
  public var pid: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由更新请求参数
public struct Api_Core_TenantRouteUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// name
  public var name: String = String()

  /// url
  public var url: String = String()

  /// pid
  public var pid: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由删除返回参数
public struct Api_Core_TenantRouteDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台角色列表请求参数
public struct Api_Core_TenantRoleListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// name
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
  fileprivate var _name: String? = nil
}

/// 商户后台角色列表返回参数
public struct Api_Core_TenantRoleListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// list
  public var list: [Api_Common_TenantRole] = []

  /// total
  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
}

/// 商户后台路由创建请求参数
public struct Api_Core_TenantRoleCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name
  public var name: String = String()

  /// is_super
  public var isSuper: Api_Common_TenantIsSuper = .isSuperDefault

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由更新请求参数
public struct Api_Core_TenantRoleUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// name
  public var name: String = String()

  /// is_super
  public var isSuper: Api_Common_TenantIsSuper = .isSuperDefault

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由删除返回参数
public struct Api_Core_TenantRoleDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由列表树请求参数
public struct Api_Core_TenantRoleRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// role_id
  public var roleID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台路由列表树返回参数
public struct Api_Core_TenantRoleRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list
  public var list: [Api_Common_TenantRouteWithItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台角色列表请求参数
public struct Api_Core_TenantRoleRouteUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// role_id
  public var roleID: Int32 = 0

  /// route_ids
  public var routeIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员列表请求参数
public struct Api_Core_TenantManagerListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// account
  public var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// role_id
  public var roleID: Int32 {
    get {return _roleID ?? 0}
    set {_roleID = newValue}
  }
  /// Returns true if `roleID` has been explicitly set.
  public var hasRoleID: Bool {return self._roleID != nil}
  /// Clears the value of `roleID`. Subsequent reads from it will return its default value.
  public mutating func clearRoleID() {self._roleID = nil}

  /// status
  public var status: CommonDisableStatus {
    get {return _status ?? .default}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
  fileprivate var _account: String? = nil
  fileprivate var _roleID: Int32? = nil
  fileprivate var _status: CommonDisableStatus? = nil
}

/// 商户后台管理员列表返回参数
public struct Api_Core_TenantManagerListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var batch: CommonPage {
    get {return _batch ?? CommonPage()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// list
  public var list: [Api_Common_TenantManager] = []

  /// total
  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonPage? = nil
}

/// 商户后台管理员创建请求参数
public struct Api_Core_TenantManagerCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account
  public var account: String = String()

  /// password
  public var password: String = String()

  /// role_id
  public var roleID: Int32 = 0

  /// status
  public var status: CommonDisableStatus = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员更新请求参数
public struct Api_Core_TenantManagerUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  /// account
  public var account: String = String()

  /// password
  public var password: String = String()

  /// role_id
  public var roleID: Int32 = 0

  /// status
  public var status: CommonDisableStatus = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员删除返回参数
public struct Api_Core_TenantManagerDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员删除返回参数
public struct Api_Core_TenantManagerDisableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  /// status
  public var status: CommonDisableStatus = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员登陆请求参数
public struct Api_Core_TenantManagerLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account
  public var account: String = String()

  /// password
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 商户后台管理员登陆响应参数
public struct Api_Core_TenantManagerLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_GetTenantSystemSettingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 复制用户信息设置 (复制类型 1-uid 2-account)
  public var copyConfig: Api_Core_CopyConfig {
    get {return _copyConfig ?? Api_Core_CopyConfig()}
    set {_copyConfig = newValue}
  }
  /// Returns true if `copyConfig` has been explicitly set.
  public var hasCopyConfig: Bool {return self._copyConfig != nil}
  /// Clears the value of `copyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCopyConfig() {self._copyConfig = nil}

  public var expireTime: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _copyConfig: Api_Core_CopyConfig? = nil
}

public struct Api_Core_CopyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 复制类型 1-uid 2-account
  public var copyTypes: [Api_Core_copyType] = []

  /// 当前配置类型
  public var currentCopyType: Api_Common_TenantCopyType = .tctUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_copyType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 类型
  public var copyType: Api_Common_TenantCopyType = .tctUnknown

  /// 标题
  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_SetTenantSystemSettingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 设置配置类型
  public var copyType: Api_Common_TenantCopyType = .tctUnknown

  public var expireTime: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_WorkerSessionActivityLogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 分页参数
  public var page: UInt32 = 0

  /// 每页大小
  public var pageSize: UInt32 = 0

  /// 客服账号
  public var account: String {
    get {return _account ?? String()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// 客服IP
  public var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  public var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  public mutating func clearIp() {self._ip = nil}

  /// 开始时间
  public var begin: String {
    get {return _begin ?? String()}
    set {_begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  public var hasBegin: Bool {return self._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  public mutating func clearBegin() {self._begin = nil}

  /// 结束时间
  public var end: String {
    get {return _end ?? String()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: String? = nil
  fileprivate var _ip: String? = nil
  fileprivate var _begin: String? = nil
  fileprivate var _end: String? = nil
}

public struct Api_Core_WorkerSessionActivityLogItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客服ID
  public var workerID: Int32 = 0

  /// 客服账号
  public var account: String = String()

  /// 客服名称
  public var name: String = String()

  /// 客服组
  public var groupName: String = String()

  /// 登录时间
  public var loginAt: String = String()

  /// 登出时间
  public var logoutAt: String = String()

  /// IP地址
  public var ip: String = String()

  /// 设备信息
  public var deviceInfo: Api_Common_DeviceInfo {
    get {return _deviceInfo ?? Api_Common_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {self._deviceInfo = nil}

  /// 起聊版本号
  public var clientVer: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceInfo: Api_Common_DeviceInfo? = nil
}

public struct Api_Core_WorkerSessionActivityLogResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// items
  public var list: [Api_Core_WorkerSessionActivityLogItem] = []

  /// total
  public var total: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_AddQualityContentReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 优先级
  public var index: Int32 = 0

  /// 内容
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_UpdateQualityContentReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var index: Int32 = 0

  public var content: String = String()

  public var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  public var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  public mutating func clearEnable() {self._enable = nil}

  public var disable: Bool {
    get {return _disable ?? false}
    set {_disable = newValue}
  }
  /// Returns true if `disable` has been explicitly set.
  public var hasDisable: Bool {return self._disable != nil}
  /// Clears the value of `disable`. Subsequent reads from it will return its default value.
  public mutating func clearDisable() {self._disable = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _enable: Bool? = nil
  fileprivate var _disable: Bool? = nil
}

public struct Api_Core_TenantQualityContentItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var index: Int32 = 0

  public var content: String = String()

  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_TenantQualityContentListResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Api_Core_TenantQualityContentItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_LoginPlatform: @unchecked Sendable {}
extension Api_Core_RoleRoute: @unchecked Sendable {}
extension Api_Core_PageParam: @unchecked Sendable {}
extension Api_Core_RouteRequest: @unchecked Sendable {}
extension Api_Core_RouteItem: @unchecked Sendable {}
extension Api_Core_RouteResponse: @unchecked Sendable {}
extension Api_Core_CaptchaResponse: @unchecked Sendable {}
extension Api_Core_LoginRequest: @unchecked Sendable {}
extension Api_Core_LoginResponse: @unchecked Sendable {}
extension Api_Core_LogoutRequest: @unchecked Sendable {}
extension Api_Core_ManagerLoginRequest: @unchecked Sendable {}
extension Api_Core_ManagerLoginResponse: @unchecked Sendable {}
extension Api_Core_TenantCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryResponse: @unchecked Sendable {}
extension Api_Core_DeleteTenantRequest: @unchecked Sendable {}
extension Api_Core_TenantItem: @unchecked Sendable {}
extension Api_Core_AdminLoginRequest: @unchecked Sendable {}
extension Api_Core_AdminLoginResponse: @unchecked Sendable {}
extension Api_Core_UpdateTenantRequest: @unchecked Sendable {}
extension Api_Core_PublicKeyResponse: @unchecked Sendable {}
extension Api_Core_QueryTenantInfoResponse: @unchecked Sendable {}
extension Api_Core_UpdateNimInfoRequest: @unchecked Sendable {}
extension Api_Core_VersionRequest: @unchecked Sendable {}
extension Api_Core_VersionResponse: @unchecked Sendable {}
extension Api_Core_CreateVersionResponse: @unchecked Sendable {}
extension Api_Core_UpdateVersionResponse: @unchecked Sendable {}
extension Api_Core_GetVersionResponse: @unchecked Sendable {}
extension Api_Core_TenantThirdSetting: @unchecked Sendable {}
extension Api_Core_LineGroupListRequest: @unchecked Sendable {}
extension Api_Core_LineGroupListResponse: @unchecked Sendable {}
extension Api_Core_LineGroupCreateRequest: @unchecked Sendable {}
extension Api_Core_LineGroupUpdateRequest: @unchecked Sendable {}
extension Api_Core_LineGroupDeleteRequest: @unchecked Sendable {}
extension Api_Core_TenantWorkerQueryRequest: @unchecked Sendable {}
extension Api_Core_TenantWorkerQueryResponse: @unchecked Sendable {}
extension Api_Core_WorkerWithState: @unchecked Sendable {}
extension Api_Core_TenantLogReq: @unchecked Sendable {}
extension Api_Core_TenantLogItem: @unchecked Sendable {}
extension Api_Core_TenantLogResp: @unchecked Sendable {}
extension Api_Core_TenantRouteListRequest: @unchecked Sendable {}
extension Api_Core_TenantRouteListResponse: @unchecked Sendable {}
extension Api_Core_TenantRouteCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantRouteUpdateRequest: @unchecked Sendable {}
extension Api_Core_TenantRouteDeleteRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleListRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleListResponse: @unchecked Sendable {}
extension Api_Core_TenantRoleCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleUpdateRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleDeleteRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleRouteRequest: @unchecked Sendable {}
extension Api_Core_TenantRoleRouteResponse: @unchecked Sendable {}
extension Api_Core_TenantRoleRouteUpdateRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerListRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerListResponse: @unchecked Sendable {}
extension Api_Core_TenantManagerCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerUpdateRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerDeleteRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerDisableRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerLoginRequest: @unchecked Sendable {}
extension Api_Core_TenantManagerLoginResponse: @unchecked Sendable {}
extension Api_Core_GetTenantSystemSettingResponse: @unchecked Sendable {}
extension Api_Core_CopyConfig: @unchecked Sendable {}
extension Api_Core_copyType: @unchecked Sendable {}
extension Api_Core_SetTenantSystemSettingRequest: @unchecked Sendable {}
extension Api_Core_WorkerSessionActivityLogRequest: @unchecked Sendable {}
extension Api_Core_WorkerSessionActivityLogItem: @unchecked Sendable {}
extension Api_Core_WorkerSessionActivityLogResponse: @unchecked Sendable {}
extension Api_Core_AddQualityContentReq: @unchecked Sendable {}
extension Api_Core_UpdateQualityContentReq: @unchecked Sendable {}
extension Api_Core_TenantQualityContentItem: @unchecked Sendable {}
extension Api_Core_TenantQualityContentListResp: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_LoginPlatform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Dashboard"),
    1: .same(proto: "Client"),
  ]
}

extension Api_Core_RoleRoute: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Role_ROUTE_WORKER"),
    1: .same(proto: "Role_ROUTE_CUSTOMER"),
    2: .same(proto: "Role_ROUTE_ALL"),
  ]
}

extension Api_Core_PageParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt64Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PageParam, rhs: Api_Core_PageParam) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteRequest, rhs: Api_Core_RouteRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_name"),
    2: .standard(proto: "route_url"),
    3: .standard(proto: "route_role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.routeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routeURL) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.routeRole) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routeName.isEmpty {
      try visitor.visitSingularStringField(value: self.routeName, fieldNumber: 1)
    }
    if !self.routeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.routeURL, fieldNumber: 2)
    }
    if self.routeRole != 0 {
      try visitor.visitSingularInt32Field(value: self.routeRole, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteItem, rhs: Api_Core_RouteItem) -> Bool {
    if lhs.routeName != rhs.routeName {return false}
    if lhs.routeURL != rhs.routeURL {return false}
    if lhs.routeRole != rhs.routeRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteResponse, rhs: Api_Core_RouteResponse) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CaptchaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CaptchaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "captcha_key"),
    2: .standard(proto: "image_base64"),
    3: .standard(proto: "thumb_base64"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.captchaKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imageBase64) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbBase64) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.captchaKey.isEmpty {
      try visitor.visitSingularStringField(value: self.captchaKey, fieldNumber: 1)
    }
    if !self.imageBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.imageBase64, fieldNumber: 2)
    }
    if !self.thumbBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbBase64, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CaptchaResponse, rhs: Api_Core_CaptchaResponse) -> Bool {
    if lhs.captchaKey != rhs.captchaKey {return false}
    if lhs.imageBase64 != rhs.imageBase64 {return false}
    if lhs.thumbBase64 != rhs.thumbBase64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
    3: .standard(proto: "captcha_dots"),
    4: .standard(proto: "captcha_key"),
    5: .standard(proto: "login_platform"),
    6: .standard(proto: "device_info"),
    7: .standard(proto: "client_ver"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._captchaDots) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._captchaKey) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._loginPlatform) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._clientVer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try { if let v = self._captchaDots {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._captchaKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._loginPlatform {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._clientVer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginRequest, rhs: Api_Core_LoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs._captchaDots != rhs._captchaDots {return false}
    if lhs._captchaKey != rhs._captchaKey {return false}
    if lhs._loginPlatform != rhs._loginPlatform {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs._clientVer != rhs._clientVer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
    3: .standard(proto: "chat_expire_time"),
    4: .standard(proto: "bind_gl"),
    5: .standard(proto: "third_api_enabled"),
    21: .standard(proto: "background_line"),
    22: .same(proto: "clique"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._items) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.chatExpireTime) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.bindGl) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.thirdApiEnabled) }()
      case 21: try { try decoder.decodeSingularStringField(value: &self.backgroundLine) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &self.clique) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._items {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.chatExpireTime != 0 {
      try visitor.visitSingularInt32Field(value: self.chatExpireTime, fieldNumber: 3)
    }
    if self.bindGl != false {
      try visitor.visitSingularBoolField(value: self.bindGl, fieldNumber: 4)
    }
    if self.thirdApiEnabled != false {
      try visitor.visitSingularBoolField(value: self.thirdApiEnabled, fieldNumber: 5)
    }
    if !self.backgroundLine.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundLine, fieldNumber: 21)
    }
    if self.clique != 0 {
      try visitor.visitSingularInt32Field(value: self.clique, fieldNumber: 22)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginResponse, rhs: Api_Core_LoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._items != rhs._items {return false}
    if lhs.chatExpireTime != rhs.chatExpireTime {return false}
    if lhs.bindGl != rhs.bindGl {return false}
    if lhs.thirdApiEnabled != rhs.thirdApiEnabled {return false}
    if lhs.backgroundLine != rhs.backgroundLine {return false}
    if lhs.clique != rhs.clique {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "logout_platform"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularEnumField(value: &self.logoutPlatform) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logoutPlatform != .dashboard {
      try visitor.visitSingularEnumField(value: self.logoutPlatform, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LogoutRequest, rhs: Api_Core_LogoutRequest) -> Bool {
    if lhs.logoutPlatform != rhs.logoutPlatform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginRequest, rhs: Api_Core_ManagerLoginRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._items {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginResponse, rhs: Api_Core_ManagerLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._items != rhs._items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "account"),
    3: .same(proto: "password"),
    4: .standard(proto: "worker_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "clique_id"),
    7: .standard(proto: "line_group_id"),
    8: .standard(proto: "h5_line"),
    9: .standard(proto: "background_line"),
    10: .same(proto: "remark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.lineGroupID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.h5Line) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.backgroundLine) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 4)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    if self.lineGroupID != 0 {
      try visitor.visitSingularInt32Field(value: self.lineGroupID, fieldNumber: 7)
    }
    if !self.h5Line.isEmpty {
      try visitor.visitSingularStringField(value: self.h5Line, fieldNumber: 8)
    }
    if !self.backgroundLine.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundLine, fieldNumber: 9)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantCreateRequest, rhs: Api_Core_TenantCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.lineGroupID != rhs.lineGroupID {return false}
    if lhs.h5Line != rhs.h5Line {return false}
    if lhs.backgroundLine != rhs.backgroundLine {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryRequest, rhs: Api_Core_TenantQueryRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
    4: .standard(proto: "tenant_item"),
    5: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tenantItem) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    if !self.tenantItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tenantItem, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryResponse, rhs: Api_Core_TenantQueryResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.tenantItem != rhs.tenantItem {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DeleteTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DeleteTenantRequest, rhs: Api_Core_DeleteTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "tenant_public_key"),
    3: .same(proto: "name"),
    4: .standard(proto: "workers_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "entrance_num"),
    7: .standard(proto: "user_name"),
    8: .standard(proto: "average_monthly"),
    9: .standard(proto: "cumulative_volume"),
    10: .same(proto: "password"),
    11: .standard(proto: "create_at"),
    12: .standard(proto: "delete_at"),
    13: .standard(proto: "group_name"),
    14: .standard(proto: "clique_Id"),
    40: .standard(proto: "api_enabled"),
    41: .standard(proto: "api_faq_url"),
    15: .standard(proto: "api_request_url"),
    16: .standard(proto: "api_name"),
    17: .standard(proto: "api_pwd"),
    18: .standard(proto: "api_pubKey"),
    19: .standard(proto: "api_recharge_request_url"),
    20: .standard(proto: "line_group_id"),
    21: .standard(proto: "h5_line"),
    22: .standard(proto: "background_line"),
    23: .standard(proto: "line_group"),
    24: .standard(proto: "update_at"),
    25: .standard(proto: "h5_domain_cert"),
    26: .same(proto: "remark"),
  ]

  fileprivate class _StorageClass {
    var _tenantID: UInt32 = 0
    var _tenantPublicKey: String = String()
    var _name: String = String()
    var _workersCapacity: Int32 = 0
    var _dailyServiceCapacity: Int32 = 0
    var _entranceNum: Int32 = 0
    var _userName: String = String()
    var _averageMonthly: Int32 = 0
    var _cumulativeVolume: Int32 = 0
    var _password: String = String()
    var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _groupName: String = String()
    var _cliqueID: Int32 = 0
    var _apiEnabled: Bool = false
    var _apiFaqURL: String = String()
    var _apiRequestURL: String = String()
    var _apiName: String = String()
    var _apiPwd: String = String()
    var _apiPubKey: String = String()
    var _apiRechargeRequestURL: String = String()
    var _lineGroupID: Int32 = 0
    var _h5Line: String = String()
    var _backgroundLine: String = String()
    var _lineGroup: Api_Common_TenantsLineGroup? = nil
    var _updateAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _h5DomainCert: String = String()
    var _remark: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tenantID = source._tenantID
      _tenantPublicKey = source._tenantPublicKey
      _name = source._name
      _workersCapacity = source._workersCapacity
      _dailyServiceCapacity = source._dailyServiceCapacity
      _entranceNum = source._entranceNum
      _userName = source._userName
      _averageMonthly = source._averageMonthly
      _cumulativeVolume = source._cumulativeVolume
      _password = source._password
      _createAt = source._createAt
      _deleteAt = source._deleteAt
      _groupName = source._groupName
      _cliqueID = source._cliqueID
      _apiEnabled = source._apiEnabled
      _apiFaqURL = source._apiFaqURL
      _apiRequestURL = source._apiRequestURL
      _apiName = source._apiName
      _apiPwd = source._apiPwd
      _apiPubKey = source._apiPubKey
      _apiRechargeRequestURL = source._apiRechargeRequestURL
      _lineGroupID = source._lineGroupID
      _h5Line = source._h5Line
      _backgroundLine = source._backgroundLine
      _lineGroup = source._lineGroup
      _updateAt = source._updateAt
      _h5DomainCert = source._h5DomainCert
      _remark = source._remark
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._tenantID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._tenantPublicKey) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._workersCapacity) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._dailyServiceCapacity) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._entranceNum) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._userName) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._averageMonthly) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._cumulativeVolume) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createAt) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._deleteAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._cliqueID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._apiRequestURL) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._apiName) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._apiPwd) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._apiPubKey) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._apiRechargeRequestURL) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._lineGroupID) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._h5Line) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._backgroundLine) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._lineGroup) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._updateAt) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._h5DomainCert) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._remark) }()
        case 40: try { try decoder.decodeSingularBoolField(value: &_storage._apiEnabled) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._apiFaqURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._tenantID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tenantID, fieldNumber: 1)
      }
      if !_storage._tenantPublicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tenantPublicKey, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if _storage._workersCapacity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._workersCapacity, fieldNumber: 4)
      }
      if _storage._dailyServiceCapacity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dailyServiceCapacity, fieldNumber: 5)
      }
      if _storage._entranceNum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._entranceNum, fieldNumber: 6)
      }
      if !_storage._userName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userName, fieldNumber: 7)
      }
      if _storage._averageMonthly != 0 {
        try visitor.visitSingularInt32Field(value: _storage._averageMonthly, fieldNumber: 8)
      }
      if _storage._cumulativeVolume != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cumulativeVolume, fieldNumber: 9)
      }
      if !_storage._password.isEmpty {
        try visitor.visitSingularStringField(value: _storage._password, fieldNumber: 10)
      }
      try { if let v = _storage._createAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._deleteAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 13)
      }
      if _storage._cliqueID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cliqueID, fieldNumber: 14)
      }
      if !_storage._apiRequestURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiRequestURL, fieldNumber: 15)
      }
      if !_storage._apiName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiName, fieldNumber: 16)
      }
      if !_storage._apiPwd.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiPwd, fieldNumber: 17)
      }
      if !_storage._apiPubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiPubKey, fieldNumber: 18)
      }
      if !_storage._apiRechargeRequestURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiRechargeRequestURL, fieldNumber: 19)
      }
      if _storage._lineGroupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lineGroupID, fieldNumber: 20)
      }
      if !_storage._h5Line.isEmpty {
        try visitor.visitSingularStringField(value: _storage._h5Line, fieldNumber: 21)
      }
      if !_storage._backgroundLine.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backgroundLine, fieldNumber: 22)
      }
      try { if let v = _storage._lineGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._updateAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._h5DomainCert.isEmpty {
        try visitor.visitSingularStringField(value: _storage._h5DomainCert, fieldNumber: 25)
      }
      if !_storage._remark.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remark, fieldNumber: 26)
      }
      if _storage._apiEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._apiEnabled, fieldNumber: 40)
      }
      if !_storage._apiFaqURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiFaqURL, fieldNumber: 41)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantItem, rhs: Api_Core_TenantItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tenantID != rhs_storage._tenantID {return false}
        if _storage._tenantPublicKey != rhs_storage._tenantPublicKey {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._workersCapacity != rhs_storage._workersCapacity {return false}
        if _storage._dailyServiceCapacity != rhs_storage._dailyServiceCapacity {return false}
        if _storage._entranceNum != rhs_storage._entranceNum {return false}
        if _storage._userName != rhs_storage._userName {return false}
        if _storage._averageMonthly != rhs_storage._averageMonthly {return false}
        if _storage._cumulativeVolume != rhs_storage._cumulativeVolume {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._createAt != rhs_storage._createAt {return false}
        if _storage._deleteAt != rhs_storage._deleteAt {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._cliqueID != rhs_storage._cliqueID {return false}
        if _storage._apiEnabled != rhs_storage._apiEnabled {return false}
        if _storage._apiFaqURL != rhs_storage._apiFaqURL {return false}
        if _storage._apiRequestURL != rhs_storage._apiRequestURL {return false}
        if _storage._apiName != rhs_storage._apiName {return false}
        if _storage._apiPwd != rhs_storage._apiPwd {return false}
        if _storage._apiPubKey != rhs_storage._apiPubKey {return false}
        if _storage._apiRechargeRequestURL != rhs_storage._apiRechargeRequestURL {return false}
        if _storage._lineGroupID != rhs_storage._lineGroupID {return false}
        if _storage._h5Line != rhs_storage._h5Line {return false}
        if _storage._backgroundLine != rhs_storage._backgroundLine {return false}
        if _storage._lineGroup != rhs_storage._lineGroup {return false}
        if _storage._updateAt != rhs_storage._updateAt {return false}
        if _storage._h5DomainCert != rhs_storage._h5DomainCert {return false}
        if _storage._remark != rhs_storage._remark {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginRequest, rhs: Api_Core_AdminLoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginResponse, rhs: Api_Core_AdminLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "worker_capacity"),
    4: .standard(proto: "daily_service_capacity"),
    5: .same(proto: "password"),
    6: .standard(proto: "clique_id"),
    7: .same(proto: "nimprex"),
    8: .standard(proto: "line_group_id"),
    9: .standard(proto: "h5_line"),
    10: .standard(proto: "background_line"),
    11: .same(proto: "remark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nimprex) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.lineGroupID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.h5Line) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.backgroundLine) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 3)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 4)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    if !self.nimprex.isEmpty {
      try visitor.visitSingularStringField(value: self.nimprex, fieldNumber: 7)
    }
    if self.lineGroupID != 0 {
      try visitor.visitSingularInt32Field(value: self.lineGroupID, fieldNumber: 8)
    }
    if !self.h5Line.isEmpty {
      try visitor.visitSingularStringField(value: self.h5Line, fieldNumber: 9)
    }
    if !self.backgroundLine.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundLine, fieldNumber: 10)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateTenantRequest, rhs: Api_Core_UpdateTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.password != rhs.password {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.nimprex != rhs.nimprex {return false}
    if lhs.lineGroupID != rhs.lineGroupID {return false}
    if lhs.h5Line != rhs.h5Line {return false}
    if lhs.backgroundLine != rhs.backgroundLine {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_PublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PublicKeyResponse, rhs: Api_Core_PublicKeyResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryTenantInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTenantInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryTenantInfoResponse, rhs: Api_Core_QueryTenantInfoResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateNimInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNimInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workerId"),
    2: .same(proto: "nimid"),
    3: .same(proto: "nimsession"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nimid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nimsession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.nimid.isEmpty {
      try visitor.visitSingularStringField(value: self.nimid, fieldNumber: 2)
    }
    if !self.nimsession.isEmpty {
      try visitor.visitSingularStringField(value: self.nimsession, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateNimInfoRequest, rhs: Api_Core_UpdateNimInfoRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.nimid != rhs.nimid {return false}
    if lhs.nimsession != rhs.nimsession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._versionID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_VersionRequest, rhs: Api_Core_VersionRequest) -> Bool {
    if lhs._versionID != rhs._versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .standard(proto: "create_at"),
    11: .standard(proto: "update_at"),
    12: .same(proto: "status"),
    13: .same(proto: "operator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._updateAt) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try { if let v = self._createAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._updateAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 12)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_VersionResponse, rhs: Api_Core_VersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs._createAt != rhs._createAt {return false}
    if lhs._updateAt != rhs._updateAt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CreateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CreateVersionResponse, rhs: Api_Core_CreateVersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "optype"),
    3: .same(proto: "softname"),
    4: .standard(proto: "major_version"),
    5: .standard(proto: "miner_version"),
    6: .same(proto: "force"),
    7: .standard(proto: "download_url"),
    8: .standard(proto: "plist_url"),
    9: .same(proto: "remark"),
    10: .standard(proto: "create_at"),
    11: .standard(proto: "update_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.optype) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minerVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.plistURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._updateAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.versionID != 0 {
      try visitor.visitSingularInt32Field(value: self.versionID, fieldNumber: 1)
    }
    if self.optype != .operationTypeUnknown {
      try visitor.visitSingularEnumField(value: self.optype, fieldNumber: 2)
    }
    if !self.softname.isEmpty {
      try visitor.visitSingularStringField(value: self.softname, fieldNumber: 3)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 4)
    }
    if !self.minerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minerVersion, fieldNumber: 5)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.plistURL.isEmpty {
      try visitor.visitSingularStringField(value: self.plistURL, fieldNumber: 8)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 9)
    }
    try { if let v = self._createAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._updateAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateVersionResponse, rhs: Api_Core_UpdateVersionResponse) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.optype != rhs.optype {return false}
    if lhs.softname != rhs.softname {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minerVersion != rhs.minerVersion {return false}
    if lhs.force != rhs.force {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.plistURL != rhs.plistURL {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs._createAt != rhs._createAt {return false}
    if lhs._updateAt != rhs._updateAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetVersionResponse, rhs: Api_Core_GetVersionResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantThirdSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantThirdSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "api_request_url"),
    3: .standard(proto: "api_name"),
    4: .standard(proto: "api_pwd"),
    5: .standard(proto: "api_pubKey"),
    6: .standard(proto: "api_recharge_request_url"),
    7: .standard(proto: "api_enabled"),
    8: .standard(proto: "api_faq_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.apiRequestURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.apiPwd) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.apiPubKey) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.apiRechargeRequestURL) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.apiEnabled) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.apiFaqURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.apiRequestURL.isEmpty {
      try visitor.visitSingularStringField(value: self.apiRequestURL, fieldNumber: 2)
    }
    if !self.apiName.isEmpty {
      try visitor.visitSingularStringField(value: self.apiName, fieldNumber: 3)
    }
    if !self.apiPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.apiPwd, fieldNumber: 4)
    }
    if !self.apiPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiPubKey, fieldNumber: 5)
    }
    if !self.apiRechargeRequestURL.isEmpty {
      try visitor.visitSingularStringField(value: self.apiRechargeRequestURL, fieldNumber: 6)
    }
    if self.apiEnabled != false {
      try visitor.visitSingularBoolField(value: self.apiEnabled, fieldNumber: 7)
    }
    if !self.apiFaqURL.isEmpty {
      try visitor.visitSingularStringField(value: self.apiFaqURL, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantThirdSetting, rhs: Api_Core_TenantThirdSetting) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.apiRequestURL != rhs.apiRequestURL {return false}
    if lhs.apiName != rhs.apiName {return false}
    if lhs.apiPwd != rhs.apiPwd {return false}
    if lhs.apiPubKey != rhs.apiPubKey {return false}
    if lhs.apiRechargeRequestURL != rhs.apiRechargeRequestURL {return false}
    if lhs.apiEnabled != rhs.apiEnabled {return false}
    if lhs.apiFaqURL != rhs.apiFaqURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LineGroupListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineGroupListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "name"),
    3: .standard(proto: "disable_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._disableStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._disableStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LineGroupListRequest, rhs: Api_Core_LineGroupListRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._name != rhs._name {return false}
    if lhs._disableStatus != rhs._disableStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LineGroupListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineGroupListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "list"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LineGroupListResponse, rhs: Api_Core_LineGroupListResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LineGroupCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineGroupCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "h5_lines"),
    3: .standard(proto: "background_lines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._h5Lines) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._backgroundLines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._h5Lines {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._backgroundLines {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LineGroupCreateRequest, rhs: Api_Core_LineGroupCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._h5Lines != rhs._h5Lines {return false}
    if lhs._backgroundLines != rhs._backgroundLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LineGroupUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineGroupUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "h5_lines"),
    4: .standard(proto: "background_lines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._h5Lines) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._backgroundLines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._h5Lines {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._backgroundLines {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LineGroupUpdateRequest, rhs: Api_Core_LineGroupUpdateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._h5Lines != rhs._h5Lines {return false}
    if lhs._backgroundLines != rhs._backgroundLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LineGroupDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineGroupDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LineGroupDeleteRequest, rhs: Api_Core_LineGroupDeleteRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantWorkerQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantWorkerQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "tenant_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "worker_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.tenantID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.workerState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.tenantID != 0 {
      try visitor.visitSingularInt32Field(value: self.tenantID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.workerState != .workerOffline {
      try visitor.visitSingularEnumField(value: self.workerState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantWorkerQueryRequest, rhs: Api_Core_TenantWorkerQueryRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workerState != rhs.workerState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantWorkerQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantWorkerQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "batch"),
    3: .same(proto: "total"),
    4: .standard(proto: "online_total"),
    5: .standard(proto: "all_total"),
    6: .standard(proto: "workers_capacity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.onlineTotal) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.allTotal) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.workersCapacity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    if self.onlineTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.onlineTotal, fieldNumber: 4)
    }
    if self.allTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.allTotal, fieldNumber: 5)
    }
    if self.workersCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workersCapacity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantWorkerQueryResponse, rhs: Api_Core_TenantWorkerQueryResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.onlineTotal != rhs.onlineTotal {return false}
    if lhs.allTotal != rhs.allTotal {return false}
    if lhs.workersCapacity != rhs.workersCapacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerWithState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerWithState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worker"),
    2: .standard(proto: "worker_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worker) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.workerState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.workerState != .workerOffline {
      try visitor.visitSingularEnumField(value: self.workerState, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerWithState, rhs: Api_Core_WorkerWithState) -> Bool {
    if lhs._worker != rhs._worker {return false}
    if lhs.workerState != rhs.workerState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantLogReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "query_type"),
    3: .standard(proto: "user_name"),
    4: .same(proto: "role"),
    5: .same(proto: "ip"),
    6: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.queryType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.role) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._ip) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.queryType != 0 {
      try visitor.visitSingularInt32Field(value: self.queryType, fieldNumber: 2)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 3)
    }
    if self.role != 0 {
      try visitor.visitSingularInt32Field(value: self.role, fieldNumber: 4)
    }
    try { if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantLogReq, rhs: Api_Core_TenantLogReq) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.role != rhs.role {return false}
    if lhs._ip != rhs._ip {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantLogItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantLogItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "user_account"),
    4: .same(proto: "role"),
    5: .standard(proto: "create_time"),
    6: .same(proto: "detail"),
    7: .same(proto: "ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userAccount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.detail) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    if !self.userAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.userAccount, fieldNumber: 3)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 6)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantLogItem, rhs: Api_Core_TenantLogItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.userAccount != rhs.userAccount {return false}
    if lhs.role != rhs.role {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantLogResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantLogResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "logs"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantLogResp, rhs: Api_Core_TenantLogResp) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRouteListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRouteListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "name"),
    3: .same(proto: "url"),
    4: .same(proto: "pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._pid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRouteListRequest, rhs: Api_Core_TenantRouteListRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._name != rhs._name {return false}
    if lhs._url != rhs._url {return false}
    if lhs._pid != rhs._pid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRouteListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRouteListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "list"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRouteListResponse, rhs: Api_Core_TenantRouteListResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRouteCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRouteCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRouteCreateRequest, rhs: Api_Core_TenantRouteCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRouteUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRouteUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "url"),
    4: .same(proto: "pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRouteUpdateRequest, rhs: Api_Core_TenantRouteUpdateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRouteDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRouteDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRouteDeleteRequest, rhs: Api_Core_TenantRouteDeleteRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleListRequest, rhs: Api_Core_TenantRoleListRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "list"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleListResponse, rhs: Api_Core_TenantRoleListResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "is_super"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.isSuper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.isSuper != .isSuperDefault {
      try visitor.visitSingularEnumField(value: self.isSuper, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleCreateRequest, rhs: Api_Core_TenantRoleCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.isSuper != rhs.isSuper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "is_super"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.isSuper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.isSuper != .isSuperDefault {
      try visitor.visitSingularEnumField(value: self.isSuper, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleUpdateRequest, rhs: Api_Core_TenantRoleUpdateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.isSuper != rhs.isSuper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleDeleteRequest, rhs: Api_Core_TenantRoleDeleteRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleRouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleRouteRequest, rhs: Api_Core_TenantRoleRouteRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleRouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleRouteResponse, rhs: Api_Core_TenantRoleRouteResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantRoleRouteUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantRoleRouteUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
    2: .standard(proto: "route_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.routeIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 1)
    }
    if !self.routeIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.routeIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantRoleRouteUpdateRequest, rhs: Api_Core_TenantRoleRouteUpdateRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.routeIds != rhs.routeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "account"),
    4: .standard(proto: "role_id"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._roleID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._roleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerListRequest, rhs: Api_Core_TenantManagerListRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._account != rhs._account {return false}
    if lhs._roleID != rhs._roleID {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "list"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerListResponse, rhs: Api_Core_TenantManagerListResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "account"),
    3: .same(proto: "password"),
    4: .standard(proto: "role_id"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 4)
    }
    if self.status != .default {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerCreateRequest, rhs: Api_Core_TenantManagerCreateRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "account"),
    3: .same(proto: "password"),
    4: .standard(proto: "role_id"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 4)
    }
    if self.status != .default {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerUpdateRequest, rhs: Api_Core_TenantManagerUpdateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerDeleteRequest, rhs: Api_Core_TenantManagerDeleteRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerDisableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerDisableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.status != .default {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerDisableRequest, rhs: Api_Core_TenantManagerDisableRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerLoginRequest, rhs: Api_Core_TenantManagerLoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantManagerLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantManagerLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantManagerLoginResponse, rhs: Api_Core_TenantManagerLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetTenantSystemSettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTenantSystemSettingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_config"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._copyConfig) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._copyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.expireTime != 0 {
      try visitor.visitSingularInt32Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetTenantSystemSettingResponse, rhs: Api_Core_GetTenantSystemSettingResponse) -> Bool {
    if lhs._copyConfig != rhs._copyConfig {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_CopyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CopyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_types"),
    2: .standard(proto: "current_copy_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.copyTypes) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.currentCopyType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.copyTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.copyTypes, fieldNumber: 1)
    }
    if self.currentCopyType != .tctUnknown {
      try visitor.visitSingularEnumField(value: self.currentCopyType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_CopyConfig, rhs: Api_Core_CopyConfig) -> Bool {
    if lhs.copyTypes != rhs.copyTypes {return false}
    if lhs.currentCopyType != rhs.currentCopyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_copyType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".copyType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_type"),
    2: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.copyType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copyType != .tctUnknown {
      try visitor.visitSingularEnumField(value: self.copyType, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_copyType, rhs: Api_Core_copyType) -> Bool {
    if lhs.copyType != rhs.copyType {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_SetTenantSystemSettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetTenantSystemSettingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_type"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.copyType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copyType != .tctUnknown {
      try visitor.visitSingularEnumField(value: self.copyType, fieldNumber: 1)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt32Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_SetTenantSystemSettingRequest, rhs: Api_Core_SetTenantSystemSettingRequest) -> Bool {
    if lhs.copyType != rhs.copyType {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerSessionActivityLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerSessionActivityLogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .same(proto: "pageSize"),
    3: .same(proto: "account"),
    4: .same(proto: "ip"),
    5: .same(proto: "begin"),
    6: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._account) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._ip) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._begin) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    try { if let v = self._account {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._begin {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerSessionActivityLogRequest, rhs: Api_Core_WorkerSessionActivityLogRequest) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._account != rhs._account {return false}
    if lhs._ip != rhs._ip {return false}
    if lhs._begin != rhs._begin {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerSessionActivityLogItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerSessionActivityLogItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .same(proto: "account"),
    3: .same(proto: "name"),
    4: .standard(proto: "group_name"),
    5: .standard(proto: "login_at"),
    6: .standard(proto: "logout_at"),
    7: .same(proto: "ip"),
    8: .standard(proto: "device_info"),
    9: .standard(proto: "client_ver"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.loginAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.logoutAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.clientVer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 4)
    }
    if !self.loginAt.isEmpty {
      try visitor.visitSingularStringField(value: self.loginAt, fieldNumber: 5)
    }
    if !self.logoutAt.isEmpty {
      try visitor.visitSingularStringField(value: self.logoutAt, fieldNumber: 6)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 7)
    }
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.clientVer.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVer, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerSessionActivityLogItem, rhs: Api_Core_WorkerSessionActivityLogItem) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.account != rhs.account {return false}
    if lhs.name != rhs.name {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.loginAt != rhs.loginAt {return false}
    if lhs.logoutAt != rhs.logoutAt {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.clientVer != rhs.clientVer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_WorkerSessionActivityLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerSessionActivityLogResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "list"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_WorkerSessionActivityLogResponse, rhs: Api_Core_WorkerSessionActivityLogResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AddQualityContentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddQualityContentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AddQualityContentReq, rhs: Api_Core_AddQualityContentReq) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateQualityContentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateQualityContentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
    3: .same(proto: "content"),
    4: .same(proto: "enable"),
    5: .same(proto: "disable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._disable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._disable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateQualityContentReq, rhs: Api_Core_UpdateQualityContentReq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.index != rhs.index {return false}
    if lhs.content != rhs.content {return false}
    if lhs._enable != rhs._enable {return false}
    if lhs._disable != rhs._disable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQualityContentItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQualityContentItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
    3: .same(proto: "content"),
    4: .standard(proto: "create_time"),
    5: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQualityContentItem, rhs: Api_Core_TenantQualityContentItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.index != rhs.index {return false}
    if lhs.content != rhs.content {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQualityContentListResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQualityContentListResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQualityContentListResp, rhs: Api_Core_TenantQualityContentListResp) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
