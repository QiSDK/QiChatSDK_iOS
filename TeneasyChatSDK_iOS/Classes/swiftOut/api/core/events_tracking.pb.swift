// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/events_tracking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Api_Core_ClickEvents: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  //// 一级菜单
  /// 登出
  case logout // = 1

  /// 多开
  case multiWindow // = 2

  /// 接受任务
  case acceptTask // = 3

  /// 三分钟待回复
  case pendingResponse // = 4

  /// 已超市未回复
  case timeoutResponse // = 5

  /// 已接待
  case inService // = 6

  /// 历史回话
  case chatHistory // = 7

  /// 最小化
  case minimize // = 8

  /// 最大化
  case maximize // = 9

  /// 关闭窗口
  case close // = 10

  //// 二级菜单
  /// 状态切换
  case statusToggle // = 11

  /// 搜索
  case search // = 12

  /// 会话列表
  case sessionList // = 13

  //// 三级菜单
  /// 复制uid
  case copyUid // = 14

  /// 转接
  case transfer // = 15

  /// 隐藏菜单
  case menuHide // = 16

  /// 显示菜单
  case menuShow // = 17

  /// 上传文件
  case fileUpload // = 18

  /// 表情
  case emoji // = 19

  /// 截屏
  case screenshot // = 20

  /// 会话搜索
  case sessionSearch // = 21

  /// 快捷标签显示
  case quickReplyShow // = 22

  /// 快捷标签关闭
  case quickReplyHide // = 23

  /// 发送
  case send // = 24

  //// 四级菜单
  /// 用户资料展开
  case userInfoShow // = 25

  /// 用户资料收起
  case userInfoHide // = 26

  /// 复制 - 充值订单 - 订单号
  case copyRechargeID // = 27

  /// 复制 - 充值订单 - 存款人
  case copyRechargeOwner // = 28

  /// 复制 - 充值订单 - 回执邮箱
  case copyRechargeEmail // = 29

  /// 复制 - 充值订单 - 订单来源
  case copyRechargeSource // = 30

  /// 复制 - 提现订单 - 订单号
  case copyWithdrawID // = 31

  /// 复制 - 提现订单 - 提款人
  case copyWithdrawOwner // = 32

  /// 用户诉求提交
  case userReportSubmit // = 33

  /// 会话备注 - 编辑
  case noteEdit // = 34

  /// 会话备注 - 删除
  case noteDelete // = 35

  /// 会话备注 - 确定
  case noteSave // = 36

  /// 问题类型 - 双击
  case inquiryDblclick // = 37

  /// 问题类型 - 提交
  case inquirySubmit // = 38
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .logout
    case 2: self = .multiWindow
    case 3: self = .acceptTask
    case 4: self = .pendingResponse
    case 5: self = .timeoutResponse
    case 6: self = .inService
    case 7: self = .chatHistory
    case 8: self = .minimize
    case 9: self = .maximize
    case 10: self = .close
    case 11: self = .statusToggle
    case 12: self = .search
    case 13: self = .sessionList
    case 14: self = .copyUid
    case 15: self = .transfer
    case 16: self = .menuHide
    case 17: self = .menuShow
    case 18: self = .fileUpload
    case 19: self = .emoji
    case 20: self = .screenshot
    case 21: self = .sessionSearch
    case 22: self = .quickReplyShow
    case 23: self = .quickReplyHide
    case 24: self = .send
    case 25: self = .userInfoShow
    case 26: self = .userInfoHide
    case 27: self = .copyRechargeID
    case 28: self = .copyRechargeOwner
    case 29: self = .copyRechargeEmail
    case 30: self = .copyRechargeSource
    case 31: self = .copyWithdrawID
    case 32: self = .copyWithdrawOwner
    case 33: self = .userReportSubmit
    case 34: self = .noteEdit
    case 35: self = .noteDelete
    case 36: self = .noteSave
    case 37: self = .inquiryDblclick
    case 38: self = .inquirySubmit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .logout: return 1
    case .multiWindow: return 2
    case .acceptTask: return 3
    case .pendingResponse: return 4
    case .timeoutResponse: return 5
    case .inService: return 6
    case .chatHistory: return 7
    case .minimize: return 8
    case .maximize: return 9
    case .close: return 10
    case .statusToggle: return 11
    case .search: return 12
    case .sessionList: return 13
    case .copyUid: return 14
    case .transfer: return 15
    case .menuHide: return 16
    case .menuShow: return 17
    case .fileUpload: return 18
    case .emoji: return 19
    case .screenshot: return 20
    case .sessionSearch: return 21
    case .quickReplyShow: return 22
    case .quickReplyHide: return 23
    case .send: return 24
    case .userInfoShow: return 25
    case .userInfoHide: return 26
    case .copyRechargeID: return 27
    case .copyRechargeOwner: return 28
    case .copyRechargeEmail: return 29
    case .copyRechargeSource: return 30
    case .copyWithdrawID: return 31
    case .copyWithdrawOwner: return 32
    case .userReportSubmit: return 33
    case .noteEdit: return 34
    case .noteDelete: return 35
    case .noteSave: return 36
    case .inquiryDblclick: return 37
    case .inquirySubmit: return 38
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_ClickEvents: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ClickEvents] = [
    .unspecified,
    .logout,
    .multiWindow,
    .acceptTask,
    .pendingResponse,
    .timeoutResponse,
    .inService,
    .chatHistory,
    .minimize,
    .maximize,
    .close,
    .statusToggle,
    .search,
    .sessionList,
    .copyUid,
    .transfer,
    .menuHide,
    .menuShow,
    .fileUpload,
    .emoji,
    .screenshot,
    .sessionSearch,
    .quickReplyShow,
    .quickReplyHide,
    .send,
    .userInfoShow,
    .userInfoHide,
    .copyRechargeID,
    .copyRechargeOwner,
    .copyRechargeEmail,
    .copyRechargeSource,
    .copyWithdrawID,
    .copyWithdrawOwner,
    .userReportSubmit,
    .noteEdit,
    .noteDelete,
    .noteSave,
    .inquiryDblclick,
    .inquirySubmit,
  ]
}

#endif  // swift(>=4.2)

public enum Api_Core_ScrollEvents: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  //// 二级菜单
  /// 会话列表
  case sessionList // = 1

  //// 三级菜单
  /// 会话框聊天记录
  case chat // = 2

  /// 会话历史记录
  case history // = 3

  //// 四级菜单
  /// 用户信息
  case userInfo // = 4

  /// 问题类型
  case inquiry // = 5

  /// 会话备注
  case chatNote // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .sessionList
    case 2: self = .chat
    case 3: self = .history
    case 4: self = .userInfo
    case 5: self = .inquiry
    case 6: self = .chatNote
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .sessionList: return 1
    case .chat: return 2
    case .history: return 3
    case .userInfo: return 4
    case .inquiry: return 5
    case .chatNote: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_ScrollEvents: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ScrollEvents] = [
    .unspecified,
    .sessionList,
    .chat,
    .history,
    .userInfo,
    .inquiry,
    .chatNote,
  ]
}

#endif  // swift(>=4.2)

public enum Api_Core_ActionEvents: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  //// 二级菜单 
  /// 查询（输入框输入）
  case search // = 1

  ////三级菜单
  /// 右键 - 复制
  case contextMenuCopy // = 2

  /// 右键 - 回复
  case contextMenuReply // = 3

  /// 右键 - 备注
  case contextMenuNote // = 4

  /// 右键 - 撤回
  case contextMenuRecall // = 5

  /// 右键 - 编辑
  case contextMenuEdit // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .search
    case 2: self = .contextMenuCopy
    case 3: self = .contextMenuReply
    case 4: self = .contextMenuNote
    case 5: self = .contextMenuRecall
    case 6: self = .contextMenuEdit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .search: return 1
    case .contextMenuCopy: return 2
    case .contextMenuReply: return 3
    case .contextMenuNote: return 4
    case .contextMenuRecall: return 5
    case .contextMenuEdit: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_ActionEvents: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ActionEvents] = [
    .unspecified,
    .search,
    .contextMenuCopy,
    .contextMenuReply,
    .contextMenuNote,
    .contextMenuRecall,
    .contextMenuEdit,
  ]
}

#endif  // swift(>=4.2)

public struct Api_Core_TrackingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var sessionID: Int32 = 0

  public var event: Api_Core_TrackingEvent.OneOf_Event? = nil

  public var click: Api_Core_ClickEvents {
    get {
      if case .click(let v)? = event {return v}
      return .unspecified
    }
    set {event = .click(newValue)}
  }

  public var scroll: Api_Core_ScrollEvents {
    get {
      if case .scroll(let v)? = event {return v}
      return .unspecified
    }
    set {event = .scroll(newValue)}
  }

  public var action: Api_Core_ActionEvents {
    get {
      if case .action(let v)? = event {return v}
      return .unspecified
    }
    set {event = .action(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable {
    case click(Api_Core_ClickEvents)
    case scroll(Api_Core_ScrollEvents)
    case action(Api_Core_ActionEvents)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_Core_TrackingEvent.OneOf_Event, rhs: Api_Core_TrackingEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.click, .click): return {
        guard case .click(let l) = lhs, case .click(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scroll, .scroll): return {
        guard case .scroll(let l) = lhs, case .scroll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Api_Core_TrackingEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Api_Core_TrackingEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_ClickEvents: @unchecked Sendable {}
extension Api_Core_ScrollEvents: @unchecked Sendable {}
extension Api_Core_ActionEvents: @unchecked Sendable {}
extension Api_Core_TrackingEvent: @unchecked Sendable {}
extension Api_Core_TrackingEvent.OneOf_Event: @unchecked Sendable {}
extension Api_Core_TrackingEventRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_ClickEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ClickEvents_UNSPECIFIED"),
    1: .same(proto: "ClickEvents_LOGOUT"),
    2: .same(proto: "ClickEvents_MULTI_WINDOW"),
    3: .same(proto: "ClickEvents_ACCEPT_TASK"),
    4: .same(proto: "ClickEvents_PENDING_RESPONSE"),
    5: .same(proto: "ClickEvents_TIMEOUT_RESPONSE"),
    6: .same(proto: "ClickEvents_IN_SERVICE"),
    7: .same(proto: "ClickEvents_CHAT_HISTORY"),
    8: .same(proto: "ClickEvents_MINIMIZE"),
    9: .same(proto: "ClickEvents_MAXIMIZE"),
    10: .same(proto: "ClickEvents_CLOSE"),
    11: .same(proto: "ClickEvents_STATUS_TOGGLE"),
    12: .same(proto: "ClickEvents_SEARCH"),
    13: .same(proto: "ClickEvents_SESSION_LIST"),
    14: .same(proto: "ClickEvents_COPY_UID"),
    15: .same(proto: "ClickEvents_TRANSFER"),
    16: .same(proto: "ClickEvents_MENU_HIDE"),
    17: .same(proto: "ClickEvents_MENU_SHOW"),
    18: .same(proto: "ClickEvents_FILE_UPLOAD"),
    19: .same(proto: "ClickEvents_EMOJI"),
    20: .same(proto: "ClickEvents_SCREENSHOT"),
    21: .same(proto: "ClickEvents_SESSION_SEARCH"),
    22: .same(proto: "ClickEvents_QUICK_REPLY_SHOW"),
    23: .same(proto: "ClickEvents_QUICK_REPLY_HIDE"),
    24: .same(proto: "ClickEvents_SEND"),
    25: .same(proto: "ClickEvents_USER_INFO_SHOW"),
    26: .same(proto: "ClickEvents_USER_INFO_HIDE"),
    27: .same(proto: "ClickEvents_COPY_RECHARGE_ID"),
    28: .same(proto: "ClickEvents_COPY_RECHARGE_OWNER"),
    29: .same(proto: "ClickEvents_COPY_RECHARGE_EMAIL"),
    30: .same(proto: "ClickEvents_COPY_RECHARGE_SOURCE"),
    31: .same(proto: "ClickEvents_COPY_WITHDRAW_ID"),
    32: .same(proto: "ClickEvents_COPY_WITHDRAW_OWNER"),
    33: .same(proto: "ClickEvents_USER_REPORT_SUBMIT"),
    34: .same(proto: "ClickEvents_NOTE_EDIT"),
    35: .same(proto: "ClickEvents_NOTE_DELETE"),
    36: .same(proto: "ClickEvents_NOTE_SAVE"),
    37: .same(proto: "ClickEvents_INQUIRY_DBLCLICK"),
    38: .same(proto: "ClickEvents_INQUIRY_SUBMIT"),
  ]
}

extension Api_Core_ScrollEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ScrollEvents_UNSPECIFIED"),
    1: .same(proto: "ScrollEvents_SESSION_LIST"),
    2: .same(proto: "ScrollEvents_CHAT"),
    3: .same(proto: "ScrollEvents_HISTORY"),
    4: .same(proto: "ScrollEvents_USER_INFO"),
    5: .same(proto: "ScrollEvents_INQUIRY"),
    6: .same(proto: "ScrollEvents_CHAT_NOTE"),
  ]
}

extension Api_Core_ActionEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ActionEvents_UNSPECIFIED"),
    1: .same(proto: "ActionEvents_SEARCH"),
    2: .same(proto: "ActionEvents_CONTEXT_MENU_COPY"),
    3: .same(proto: "ActionEvents_CONTEXT_MENU_REPLY"),
    4: .same(proto: "ActionEvents_CONTEXT_MENU_NOTE"),
    5: .same(proto: "ActionEvents_CONTEXT_MENU_RECALL"),
    6: .same(proto: "ActionEvents_CONTEXT_MENU_EDIT"),
  ]
}

extension Api_Core_TrackingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackingEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "click"),
    4: .same(proto: "scroll"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sessionID) }()
      case 3: try {
        var v: Api_Core_ClickEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .click(v)
        }
      }()
      case 4: try {
        var v: Api_Core_ScrollEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .scroll(v)
        }
      }()
      case 5: try {
        var v: Api_Core_ActionEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .action(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.sessionID != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionID, fieldNumber: 2)
    }
    switch self.event {
    case .click?: try {
      guard case .click(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case .scroll?: try {
      guard case .scroll(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case .action?: try {
      guard case .action(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TrackingEvent, rhs: Api_Core_TrackingEvent) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TrackingEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackingEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TrackingEventRequest, rhs: Api_Core_TrackingEventRequest) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
