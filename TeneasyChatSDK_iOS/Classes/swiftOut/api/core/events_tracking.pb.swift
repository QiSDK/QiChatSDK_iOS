// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/events_tracking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Api_Core_ClickEvents: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 一级菜单 - 登录
  case login // = 0

  /// 一级菜单 - 登出
  case logout // = 1

  /// 一级菜单 - 多开
  case multiWindow // = 2

  /// 一级菜单 - 接受任务
  case acceptTask // = 3

  /// 一级菜单 - 三分钟待回复
  case pendingResponse // = 4

  /// 一级菜单 - 已超市未回复
  case timeoutResponse // = 5

  /// 一级菜单 - 已接待
  case inService // = 6

  /// 一级菜单 - 历史会话
  case chatHistory // = 7

  /// 一级菜单 - 历史会话 - 用户UID
  case chatHistoryUid // = 8

  /// 一级菜单 - 历史会话 - 用户称呼
  case chatHistoryUsername // = 9

  /// 一级菜单 - 历史会话 - 重置
  case chatHistoryReset // = 10

  /// 一级菜单 - 历史会话 - 搜索
  case chatHistorySearch // = 11

  /// 一级菜单 - 历史会话 - 查看
  case chatHistoryCheck // = 12

  /// 一级菜单 - 最小化
  case minimize // = 13

  /// 一级菜单 - 最大化
  case maximize // = 14

  /// 一级菜单 - 关闭窗口
  case close // = 15

  /// 二级菜单 - 状态切换
  case statusChange // = 100

  /// 二级菜单 - 取消状态切换申请
  case statusChangeCancel // = 101

  /// 二级菜单 - 确认状态切换申请
  case statusChangeConfirm // = 102

  /// 二级菜单 - 一件解绑
  case statusUnbind // = 103

  /// 二级菜单 - 搜索
  case search // = 104

  /// 二级菜单 - 会话列表
  case sessionList // = 105

  /// 三级菜单 - 复制uid
  case copyUid // = 200

  /// 三级菜单 - 刷新
  case refresh // = 201

  /// 三级菜单 - 转接
  case transfer // = 202

  /// 三级菜单 - 转接 - 选择客服咨询类型
  case transferConsultType // = 203

  /// 三级菜单 - 转接 - 转接任务到XXX
  case transferConsult // = 204

  /// 三级菜单 - 转接 - 关闭
  case transferConsultClose // = 205

  /// 三级菜单 - 隐藏菜单
  case menuHide // = 206

  /// 三级菜单 - 显示菜单
  case menuShow // = 207

  /// 三级菜单 - 上传文件
  case fileUpload // = 208

  /// 三级菜单 - 表情
  case emoji // = 209

  /// 三级菜单 - 截屏
  case screenshot // = 210

  /// 三级菜单 - 会话搜索
  case sessionSearch // = 211

  /// 三级菜单 - 会话搜索 - 关闭
  case sessionSearchClose // = 212

  /// 三级菜单 - 会话搜索 - 日期选择
  case sessionSearchDate // = 213

  /// 三级菜单 - 会话搜索 - 关键字搜索
  case sessionSearchKeywords // = 214

  /// 三级菜单 - 会话搜索 - 咨询类型
  case sessionSearchConsult // = 215

  /// 三级菜单 - 会话搜索 - 图片查看
  case sessionSearchImg // = 216

  /// 三级菜单 - 会话搜索 - 图片下载
  case sessionSearchImgDownload // = 217

  /// 三级菜单 - 会话搜索 - 图片复制
  case sessionSearchImgCopy // = 218

  /// 三级菜单 - 会话搜索 - 视频播放
  case sessionSearchVideo // = 219

  /// 三级菜单 - 会话搜索 - 视频下载
  case sessionSearchVideoDownload // = 220

  /// 三级菜单 - 会话搜索 - 视频复制
  case sessionSearchVideoCopy // = 221

  /// 三级菜单 - 会话搜索 - 视频全屏查看
  case sessionSearchVideoFullscreen // = 222

  /// 三级菜单 - 会话搜索 - 视频浏览器播放
  case sessionSearchVideoBrowser // = 223

  /// 三级菜单 - 快捷标签显示
  case quickReplyShow // = 224

  /// 三级菜单 - 快捷标签关闭
  case quickReplyHide // = 225

  /// 三级菜单 - 切换快捷标签
  case quickReplyToggle // = 226

  /// 三级菜单 - 添加常用便签
  case noteAdd // = 227

  /// 三级菜单 - 移除常用便签
  case noteDelete // = 228

  /// 三级菜单 - 常用便签翻页
  case notePagination // = 229

  /// 三级菜单 - 常用便签内容
  case noteContent // = 230

  /// 三级菜单 - 发送消息
  case send // = 231

  /// 三级菜单 - 下载视频
  case videoDownload // = 232

  /// 三级菜单 - 放大图片
  case imgZoomIn // = 233

  /// 三级菜单 - 播放视频
  case video // = 234

  /// 三级菜单 - 视频浏览器打开
  case videoBrowser // = 235

  /// 三级菜单 - 视频全屏
  case videoFullscreen // = 236

  /// 四级菜单 - 用户资料展开
  case userInfoShow // = 300

  /// 四级菜单 - 用户资料收起
  case userInfoHide // = 301

  /// 四级菜单 - 订单重新加载
  case rechargeRefresh // = 302

  /// 四级菜单 - 复制 - 充值订单 - 订单号
  case copyRechargeID // = 303

  /// 四级菜单 - 复制 - 充值订单 - 存款人
  case copyRechargeOwner // = 304

  /// 四级菜单 - 复制 - 充值订单 - 回执邮箱
  case copyRechargeEmail // = 305

  /// 四级菜单 - 复制 - 充值订单 - 订单来源
  case copyRechargeSource // = 306

  /// 四级菜单 - 复制 - 提现订单 - 订单号
  case copyWithdrawID // = 307

  /// 四级菜单 - 复制 - 提现订单 - 提款人
  case copyWithdrawOwner // = 308

  /// 四级菜单 - 用户诉求提交
  case userReportSubmit // = 309

  /// 四级菜单 - 会话备注 - 打开
  case sessionNoteOpen // = 310

  /// 四级菜单 - 会话备注 - 关闭
  case sessionNoteClose // = 311

  /// 四级菜单 - 会话备注 - 编辑
  case sessionNoteEdit // = 312

  /// 四级菜单 - 会话备注 - 编辑确定
  case sessionNoteEditSave // = 313

  /// 四级菜单 - 会话备注 - 删除
  case sessionNoteDelete // = 314

  /// 四级菜单 - 会话备注 - 确定
  case sessionNoteSave // = 315

  /// 四级菜单 - 会话备注 - 取消
  case sessionNoteCancel // = 316

  /// 四级菜单 - 问题类型 - 勾选
  case inquirySelect // = 317

  /// 四级菜单 - 问题类型 - 取消勾选
  case inquiryUnselect // = 318

  /// 四级菜单 - 问题类型 - 提交
  case inquirySubmit // = 319

  /// 四级菜单 - 问题类型 - 刷新
  case inquiryRefresh // = 320

  /// 四级菜单 - 问题类型 - 展开
  case inquiryShow // = 321

  /// 四级菜单 - 问题类型 - 关闭
  case inquiryClose // = 322
  case UNRECOGNIZED(Int)

  public init() {
    self = .login
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .login
    case 1: self = .logout
    case 2: self = .multiWindow
    case 3: self = .acceptTask
    case 4: self = .pendingResponse
    case 5: self = .timeoutResponse
    case 6: self = .inService
    case 7: self = .chatHistory
    case 8: self = .chatHistoryUid
    case 9: self = .chatHistoryUsername
    case 10: self = .chatHistoryReset
    case 11: self = .chatHistorySearch
    case 12: self = .chatHistoryCheck
    case 13: self = .minimize
    case 14: self = .maximize
    case 15: self = .close
    case 100: self = .statusChange
    case 101: self = .statusChangeCancel
    case 102: self = .statusChangeConfirm
    case 103: self = .statusUnbind
    case 104: self = .search
    case 105: self = .sessionList
    case 200: self = .copyUid
    case 201: self = .refresh
    case 202: self = .transfer
    case 203: self = .transferConsultType
    case 204: self = .transferConsult
    case 205: self = .transferConsultClose
    case 206: self = .menuHide
    case 207: self = .menuShow
    case 208: self = .fileUpload
    case 209: self = .emoji
    case 210: self = .screenshot
    case 211: self = .sessionSearch
    case 212: self = .sessionSearchClose
    case 213: self = .sessionSearchDate
    case 214: self = .sessionSearchKeywords
    case 215: self = .sessionSearchConsult
    case 216: self = .sessionSearchImg
    case 217: self = .sessionSearchImgDownload
    case 218: self = .sessionSearchImgCopy
    case 219: self = .sessionSearchVideo
    case 220: self = .sessionSearchVideoDownload
    case 221: self = .sessionSearchVideoCopy
    case 222: self = .sessionSearchVideoFullscreen
    case 223: self = .sessionSearchVideoBrowser
    case 224: self = .quickReplyShow
    case 225: self = .quickReplyHide
    case 226: self = .quickReplyToggle
    case 227: self = .noteAdd
    case 228: self = .noteDelete
    case 229: self = .notePagination
    case 230: self = .noteContent
    case 231: self = .send
    case 232: self = .videoDownload
    case 233: self = .imgZoomIn
    case 234: self = .video
    case 235: self = .videoBrowser
    case 236: self = .videoFullscreen
    case 300: self = .userInfoShow
    case 301: self = .userInfoHide
    case 302: self = .rechargeRefresh
    case 303: self = .copyRechargeID
    case 304: self = .copyRechargeOwner
    case 305: self = .copyRechargeEmail
    case 306: self = .copyRechargeSource
    case 307: self = .copyWithdrawID
    case 308: self = .copyWithdrawOwner
    case 309: self = .userReportSubmit
    case 310: self = .sessionNoteOpen
    case 311: self = .sessionNoteClose
    case 312: self = .sessionNoteEdit
    case 313: self = .sessionNoteEditSave
    case 314: self = .sessionNoteDelete
    case 315: self = .sessionNoteSave
    case 316: self = .sessionNoteCancel
    case 317: self = .inquirySelect
    case 318: self = .inquiryUnselect
    case 319: self = .inquirySubmit
    case 320: self = .inquiryRefresh
    case 321: self = .inquiryShow
    case 322: self = .inquiryClose
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .login: return 0
    case .logout: return 1
    case .multiWindow: return 2
    case .acceptTask: return 3
    case .pendingResponse: return 4
    case .timeoutResponse: return 5
    case .inService: return 6
    case .chatHistory: return 7
    case .chatHistoryUid: return 8
    case .chatHistoryUsername: return 9
    case .chatHistoryReset: return 10
    case .chatHistorySearch: return 11
    case .chatHistoryCheck: return 12
    case .minimize: return 13
    case .maximize: return 14
    case .close: return 15
    case .statusChange: return 100
    case .statusChangeCancel: return 101
    case .statusChangeConfirm: return 102
    case .statusUnbind: return 103
    case .search: return 104
    case .sessionList: return 105
    case .copyUid: return 200
    case .refresh: return 201
    case .transfer: return 202
    case .transferConsultType: return 203
    case .transferConsult: return 204
    case .transferConsultClose: return 205
    case .menuHide: return 206
    case .menuShow: return 207
    case .fileUpload: return 208
    case .emoji: return 209
    case .screenshot: return 210
    case .sessionSearch: return 211
    case .sessionSearchClose: return 212
    case .sessionSearchDate: return 213
    case .sessionSearchKeywords: return 214
    case .sessionSearchConsult: return 215
    case .sessionSearchImg: return 216
    case .sessionSearchImgDownload: return 217
    case .sessionSearchImgCopy: return 218
    case .sessionSearchVideo: return 219
    case .sessionSearchVideoDownload: return 220
    case .sessionSearchVideoCopy: return 221
    case .sessionSearchVideoFullscreen: return 222
    case .sessionSearchVideoBrowser: return 223
    case .quickReplyShow: return 224
    case .quickReplyHide: return 225
    case .quickReplyToggle: return 226
    case .noteAdd: return 227
    case .noteDelete: return 228
    case .notePagination: return 229
    case .noteContent: return 230
    case .send: return 231
    case .videoDownload: return 232
    case .imgZoomIn: return 233
    case .video: return 234
    case .videoBrowser: return 235
    case .videoFullscreen: return 236
    case .userInfoShow: return 300
    case .userInfoHide: return 301
    case .rechargeRefresh: return 302
    case .copyRechargeID: return 303
    case .copyRechargeOwner: return 304
    case .copyRechargeEmail: return 305
    case .copyRechargeSource: return 306
    case .copyWithdrawID: return 307
    case .copyWithdrawOwner: return 308
    case .userReportSubmit: return 309
    case .sessionNoteOpen: return 310
    case .sessionNoteClose: return 311
    case .sessionNoteEdit: return 312
    case .sessionNoteEditSave: return 313
    case .sessionNoteDelete: return 314
    case .sessionNoteSave: return 315
    case .sessionNoteCancel: return 316
    case .inquirySelect: return 317
    case .inquiryUnselect: return 318
    case .inquirySubmit: return 319
    case .inquiryRefresh: return 320
    case .inquiryShow: return 321
    case .inquiryClose: return 322
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ClickEvents] = [
    .login,
    .logout,
    .multiWindow,
    .acceptTask,
    .pendingResponse,
    .timeoutResponse,
    .inService,
    .chatHistory,
    .chatHistoryUid,
    .chatHistoryUsername,
    .chatHistoryReset,
    .chatHistorySearch,
    .chatHistoryCheck,
    .minimize,
    .maximize,
    .close,
    .statusChange,
    .statusChangeCancel,
    .statusChangeConfirm,
    .statusUnbind,
    .search,
    .sessionList,
    .copyUid,
    .refresh,
    .transfer,
    .transferConsultType,
    .transferConsult,
    .transferConsultClose,
    .menuHide,
    .menuShow,
    .fileUpload,
    .emoji,
    .screenshot,
    .sessionSearch,
    .sessionSearchClose,
    .sessionSearchDate,
    .sessionSearchKeywords,
    .sessionSearchConsult,
    .sessionSearchImg,
    .sessionSearchImgDownload,
    .sessionSearchImgCopy,
    .sessionSearchVideo,
    .sessionSearchVideoDownload,
    .sessionSearchVideoCopy,
    .sessionSearchVideoFullscreen,
    .sessionSearchVideoBrowser,
    .quickReplyShow,
    .quickReplyHide,
    .quickReplyToggle,
    .noteAdd,
    .noteDelete,
    .notePagination,
    .noteContent,
    .send,
    .videoDownload,
    .imgZoomIn,
    .video,
    .videoBrowser,
    .videoFullscreen,
    .userInfoShow,
    .userInfoHide,
    .rechargeRefresh,
    .copyRechargeID,
    .copyRechargeOwner,
    .copyRechargeEmail,
    .copyRechargeSource,
    .copyWithdrawID,
    .copyWithdrawOwner,
    .userReportSubmit,
    .sessionNoteOpen,
    .sessionNoteClose,
    .sessionNoteEdit,
    .sessionNoteEditSave,
    .sessionNoteDelete,
    .sessionNoteSave,
    .sessionNoteCancel,
    .inquirySelect,
    .inquiryUnselect,
    .inquirySubmit,
    .inquiryRefresh,
    .inquiryShow,
    .inquiryClose,
  ]

}

public enum Api_Core_ScrollEvents: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 二级菜单 - 会话列表
  case menu2Chat // = 0

  /// 二级菜单 - 历史记录
  case menu2History // = 1

  /// 三级菜单 - 会话框聊天记录
  case menu3Chat // = 100

  /// 三级菜单 - 会话历史记录
  case menu3History // = 101

  /// 三级菜单 - 转接列表
  case transferList // = 102

  /// 四级菜单 - 用户信息
  case userInfo // = 200

  /// 四级菜单 - 问题类型
  case inquiry // = 201

  /// 四级菜单 - 会话备注
  case chatNote // = 202
  case UNRECOGNIZED(Int)

  public init() {
    self = .menu2Chat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .menu2Chat
    case 1: self = .menu2History
    case 100: self = .menu3Chat
    case 101: self = .menu3History
    case 102: self = .transferList
    case 200: self = .userInfo
    case 201: self = .inquiry
    case 202: self = .chatNote
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .menu2Chat: return 0
    case .menu2History: return 1
    case .menu3Chat: return 100
    case .menu3History: return 101
    case .transferList: return 102
    case .userInfo: return 200
    case .inquiry: return 201
    case .chatNote: return 202
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ScrollEvents] = [
    .menu2Chat,
    .menu2History,
    .menu3Chat,
    .menu3History,
    .transferList,
    .userInfo,
    .inquiry,
    .chatNote,
  ]

}

public enum Api_Core_ActionEvents: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 一级菜单 - 历史会话 - 搜索框输入
  case historySearch // = 0

  /// 一级菜单 - 历史会话 - 消息内容输入框输入
  case historySearchMsg // = 1

  /// 二级菜单 - 查询（输入框输入）
  case search // = 100

  /// 三级菜单 - 右键 - 复制消息
  case contextMenuCopyMsg // = 200

  /// 三级菜单 - 右键 - 复制图片
  case contextMenuCopyImg // = 201

  /// 三级菜单 - 右键 - 复制图片链接
  case contextMenuCopyImgLink // = 202

  /// 三级菜单 - 右键 - 复制视频链接
  case contextMenuCopyVideoLink // = 203

  /// 三级菜单 - 右键 - 复制表情
  case contextMenuCopyEmoji // = 204

  /// 三级菜单 - 右键 - 回复了一个表情
  case contextMenuReplyEmoji // = 205

  /// 三级菜单 - 右键 - 回复了一张图片
  case contextMenuReplyImg // = 206

  /// 三级菜单 - 右键 - 回复了一条视频
  case contextMenuReplyVideo // = 207

  /// 三级菜单 - 右键 - 回复了一条消息
  case contextMenuReplyMsg // = 208

  /// 三级菜单 - 右键 - 备注了一个表情
  case contextMenuNoteEmoji // = 209

  /// 三级菜单 - 右键 - 备注了一张图片
  case contextMenuNoteImg // = 210

  /// 三级菜单 - 右键 - 备注了一条视频
  case contextMenuNoteVideo // = 211

  /// 三级菜单 - 右键 - 备注了一条消息
  case contextMenuNoteMsg // = 212

  /// 三级菜单 - 右键 - 编辑了一个表情
  case contextMenuEditEmoji // = 213

  /// 三级菜单 - 右键 - 编辑了一张图片
  case contextMenuEditImg // = 214

  /// 三级菜单 - 右键 - 编辑了一条消息
  case contextMenuEditMsg // = 215

  /// 三级菜单 - 右键 - 撤回了一条消息
  case contextMenuRecallMsg // = 216

  /// 三级菜单 - 右键 - 撤回了一张图片
  case contextMenuRecallImg // = 217

  /// 三级菜单 - 右键 - 撤回了一条视频
  case contextMenuRecallVideo // = 218

  /// 三级菜单 - 右键 - 撤回了一个表情
  case contextMenuRecallEmoji // = 219

  /// 三级菜单 - 右键 - 下载图片
  case contextMenuDownloadImg // = 220

  /// 三级菜单 - 右键 - 下载视频
  case contextMenuDownloadVideo // = 221

  /// 三级菜单 - 转接输入框
  case transferSearch // = 222

  /// 三级菜单 - 会话搜索关键字输入
  case sessionSearchKeywords // = 223

  /// 三级菜单 - 快捷便签关键字输入
  case quickReplySearchKeywords // = 224

  /// 三级菜单 - 会话框消息输入
  case sessionInput // = 225

  /// 四级菜单 - 用户诉求输入内容
  case ticketContentInput // = 300

  /// 四级菜单 - 会话备注输入内容
  case sessionNoteContentInput // = 301
  case UNRECOGNIZED(Int)

  public init() {
    self = .historySearch
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .historySearch
    case 1: self = .historySearchMsg
    case 100: self = .search
    case 200: self = .contextMenuCopyMsg
    case 201: self = .contextMenuCopyImg
    case 202: self = .contextMenuCopyImgLink
    case 203: self = .contextMenuCopyVideoLink
    case 204: self = .contextMenuCopyEmoji
    case 205: self = .contextMenuReplyEmoji
    case 206: self = .contextMenuReplyImg
    case 207: self = .contextMenuReplyVideo
    case 208: self = .contextMenuReplyMsg
    case 209: self = .contextMenuNoteEmoji
    case 210: self = .contextMenuNoteImg
    case 211: self = .contextMenuNoteVideo
    case 212: self = .contextMenuNoteMsg
    case 213: self = .contextMenuEditEmoji
    case 214: self = .contextMenuEditImg
    case 215: self = .contextMenuEditMsg
    case 216: self = .contextMenuRecallMsg
    case 217: self = .contextMenuRecallImg
    case 218: self = .contextMenuRecallVideo
    case 219: self = .contextMenuRecallEmoji
    case 220: self = .contextMenuDownloadImg
    case 221: self = .contextMenuDownloadVideo
    case 222: self = .transferSearch
    case 223: self = .sessionSearchKeywords
    case 224: self = .quickReplySearchKeywords
    case 225: self = .sessionInput
    case 300: self = .ticketContentInput
    case 301: self = .sessionNoteContentInput
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .historySearch: return 0
    case .historySearchMsg: return 1
    case .search: return 100
    case .contextMenuCopyMsg: return 200
    case .contextMenuCopyImg: return 201
    case .contextMenuCopyImgLink: return 202
    case .contextMenuCopyVideoLink: return 203
    case .contextMenuCopyEmoji: return 204
    case .contextMenuReplyEmoji: return 205
    case .contextMenuReplyImg: return 206
    case .contextMenuReplyVideo: return 207
    case .contextMenuReplyMsg: return 208
    case .contextMenuNoteEmoji: return 209
    case .contextMenuNoteImg: return 210
    case .contextMenuNoteVideo: return 211
    case .contextMenuNoteMsg: return 212
    case .contextMenuEditEmoji: return 213
    case .contextMenuEditImg: return 214
    case .contextMenuEditMsg: return 215
    case .contextMenuRecallMsg: return 216
    case .contextMenuRecallImg: return 217
    case .contextMenuRecallVideo: return 218
    case .contextMenuRecallEmoji: return 219
    case .contextMenuDownloadImg: return 220
    case .contextMenuDownloadVideo: return 221
    case .transferSearch: return 222
    case .sessionSearchKeywords: return 223
    case .quickReplySearchKeywords: return 224
    case .sessionInput: return 225
    case .ticketContentInput: return 300
    case .sessionNoteContentInput: return 301
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_ActionEvents] = [
    .historySearch,
    .historySearchMsg,
    .search,
    .contextMenuCopyMsg,
    .contextMenuCopyImg,
    .contextMenuCopyImgLink,
    .contextMenuCopyVideoLink,
    .contextMenuCopyEmoji,
    .contextMenuReplyEmoji,
    .contextMenuReplyImg,
    .contextMenuReplyVideo,
    .contextMenuReplyMsg,
    .contextMenuNoteEmoji,
    .contextMenuNoteImg,
    .contextMenuNoteVideo,
    .contextMenuNoteMsg,
    .contextMenuEditEmoji,
    .contextMenuEditImg,
    .contextMenuEditMsg,
    .contextMenuRecallMsg,
    .contextMenuRecallImg,
    .contextMenuRecallVideo,
    .contextMenuRecallEmoji,
    .contextMenuDownloadImg,
    .contextMenuDownloadVideo,
    .transferSearch,
    .sessionSearchKeywords,
    .quickReplySearchKeywords,
    .sessionInput,
    .ticketContentInput,
    .sessionNoteContentInput,
  ]

}

public enum Api_Core_EventCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 点击
  case click // = 0

  /// 滑动
  case scroll // = 1

  /// 点击 - 发送消息
  case clickSend // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .click
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .click
    case 1: self = .scroll
    case 2: self = .clickSend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .click: return 0
    case .scroll: return 1
    case .clickSend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Api_Core_EventCategory] = [
    .click,
    .scroll,
    .clickSend,
  ]

}

public struct Api_Core_EventTracking: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var sessionID: Int32 = 0

  public var event: Api_Core_EventTracking.OneOf_Event? = nil

  public var click: Api_Core_ClickEvents {
    get {
      if case .click(let v)? = event {return v}
      return .login
    }
    set {event = .click(newValue)}
  }

  public var scroll: Api_Core_ScrollEvents {
    get {
      if case .scroll(let v)? = event {return v}
      return .menu2Chat
    }
    set {event = .scroll(newValue)}
  }

  public var action: Api_Core_ActionEvents {
    get {
      if case .action(let v)? = event {return v}
      return .historySearch
    }
    set {event = .action(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable, Sendable {
    case click(Api_Core_ClickEvents)
    case scroll(Api_Core_ScrollEvents)
    case action(Api_Core_ActionEvents)

  }

  public init() {}
}

public struct Api_Core_EventTrackingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Api_Core_EventTracking] = []

  public var workerName: String = String()

  public var workerAccount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TimeRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTs = newValue}
  }
  /// Returns true if `startTs` has been explicitly set.
  public var hasStartTs: Bool {return self._startTs != nil}
  /// Clears the value of `startTs`. Subsequent reads from it will return its default value.
  public mutating func clearStartTs() {self._startTs = nil}

  public var endTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTs = newValue}
  }
  /// Returns true if `endTs` has been explicitly set.
  public var hasEndTs: Bool {return self._endTs != nil}
  /// Clears the value of `endTs`. Subsequent reads from it will return its default value.
  public mutating func clearEndTs() {self._endTs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_EventTrackingDetailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: UInt32 = 0

  public var hourly: Bool = false

  public var timeRange: Api_Core_TimeRange {
    get {return _timeRange ?? Api_Core_TimeRange()}
    set {_timeRange = newValue}
  }
  /// Returns true if `timeRange` has been explicitly set.
  public var hasTimeRange: Bool {return self._timeRange != nil}
  /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
  public mutating func clearTimeRange() {self._timeRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeRange: Api_Core_TimeRange? = nil
}

public struct Api_Core_EventTrackingDetailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [Api_Core_EventTrackingDetailResponse.EventTrackingDetailItem] = []

  public var total: UInt32 = 0

  public var validSessionCount: UInt32 = 0

  public var avgRespTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EventTrackingDetailItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hour: String = String()

    public var clicks: UInt32 = 0

    public var scrolls: UInt32 = 0

    public var sends: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Api_Core_EventTrackingListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: UInt32 = 0

  public var eventCategory: Api_Core_EventCategory {
    get {return _eventCategory ?? .click}
    set {_eventCategory = newValue}
  }
  /// Returns true if `eventCategory` has been explicitly set.
  public var hasEventCategory: Bool {return self._eventCategory != nil}
  /// Clears the value of `eventCategory`. Subsequent reads from it will return its default value.
  public mutating func clearEventCategory() {self._eventCategory = nil}

  /// timestamp, tenant_id, worker_id
  public var cursor: String = String()

  public var reverse: Bool = false

  public var limit: UInt32 = 0

  public var timeRange: Api_Core_TimeRange {
    get {return _timeRange ?? Api_Core_TimeRange()}
    set {_timeRange = newValue}
  }
  /// Returns true if `timeRange` has been explicitly set.
  public var hasTimeRange: Bool {return self._timeRange != nil}
  /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
  public mutating func clearTimeRange() {self._timeRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _eventCategory: Api_Core_EventCategory? = nil
  fileprivate var _timeRange: Api_Core_TimeRange? = nil
}

public struct Api_Core_EventTrackingListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Api_Core_EventTrackingListResponse.EventTrackingItem] = []

  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EventTrackingItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestamp: String = String()

    public var timeTaken: UInt32 = 0

    public var eventCategory: String = String()

    public var eventType: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Api_Core_EventTrackingDailyStatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int32 = 0

  public var workerID: UInt32 = 0

  public var workerAccount: String = String()

  public var workerStatus: Api_Common_WorkerState {
    get {return _workerStatus ?? .workerOffline}
    set {_workerStatus = newValue}
  }
  /// Returns true if `workerStatus` has been explicitly set.
  public var hasWorkerStatus: Bool {return self._workerStatus != nil}
  /// Clears the value of `workerStatus`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerStatus() {self._workerStatus = nil}

  public var page: UInt32 = 0

  public var pageSize: UInt32 = 0

  public var timeRange: Api_Core_TimeRange {
    get {return _timeRange ?? Api_Core_TimeRange()}
    set {_timeRange = newValue}
  }
  /// Returns true if `timeRange` has been explicitly set.
  public var hasTimeRange: Bool {return self._timeRange != nil}
  /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
  public mutating func clearTimeRange() {self._timeRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workerStatus: Api_Common_WorkerState? = nil
  fileprivate var _timeRange: Api_Core_TimeRange? = nil
}

public struct Api_Core_EventTrackingDailyStatsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: [Api_Core_EventTrackingDailyStatsResponse.EventTrackingDailyStatsItem] = []

  public var total: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EventTrackingDailyStatsItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 日期
    public var date: String = String()

    /// 客服ID
    public var workerID: UInt32 = 0

    /// 最近一次离岗时长
    public var lastAlarmTriggerTime: String = String()

    /// 离岗次数
    public var alarmTriggerCount: UInt32 = 0

    /// 离岗总时长
    public var alarmDuration: UInt64 = 0

    /// 点击次数
    public var clickCount: UInt32 = 0

    /// 点击耗时
    public var clickDuration: UInt64 = 0

    /// 滑动次数
    public var scrollCount: UInt32 = 0

    /// 滑动耗时
    public var scrollDuration: UInt64 = 0

    /// 发送次数
    public var sendCount: UInt32 = 0

    /// 发送耗时
    public var sendDuration: UInt64 = 0

    /// 活动轨迹时长
    public var totalDuration: UInt64 = 0

    /// 当前状态
    public var workerStatus: Api_Common_WorkerState = .workerOffline

    /// 客服昵称/账号
    public var workerAcc: String = String()

    /// 平均首次响应时长
    public var avgRespTime: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_ClickEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ClickEvents_LOGIN"),
    1: .same(proto: "ClickEvents_LOGOUT"),
    2: .same(proto: "ClickEvents_MULTI_WINDOW"),
    3: .same(proto: "ClickEvents_ACCEPT_TASK"),
    4: .same(proto: "ClickEvents_PENDING_RESPONSE"),
    5: .same(proto: "ClickEvents_TIMEOUT_RESPONSE"),
    6: .same(proto: "ClickEvents_IN_SERVICE"),
    7: .same(proto: "ClickEvents_CHAT_HISTORY"),
    8: .same(proto: "ClickEvents_CHAT_HISTORY_UID"),
    9: .same(proto: "ClickEvents_CHAT_HISTORY_USERNAME"),
    10: .same(proto: "ClickEvents_CHAT_HISTORY_RESET"),
    11: .same(proto: "ClickEvents_CHAT_HISTORY_SEARCH"),
    12: .same(proto: "ClickEvents_CHAT_HISTORY_CHECK"),
    13: .same(proto: "ClickEvents_MINIMIZE"),
    14: .same(proto: "ClickEvents_MAXIMIZE"),
    15: .same(proto: "ClickEvents_CLOSE"),
    100: .same(proto: "ClickEvents_STATUS_CHANGE"),
    101: .same(proto: "ClickEvents_STATUS_CHANGE_CANCEL"),
    102: .same(proto: "ClickEvents_STATUS_CHANGE_CONFIRM"),
    103: .same(proto: "ClickEvents_STATUS_UNBIND"),
    104: .same(proto: "ClickEvents_SEARCH"),
    105: .same(proto: "ClickEvents_SESSION_LIST"),
    200: .same(proto: "ClickEvents_COPY_UID"),
    201: .same(proto: "ClickEvents_REFRESH"),
    202: .same(proto: "ClickEvents_TRANSFER"),
    203: .same(proto: "ClickEvents_TRANSFER_CONSULT_TYPE"),
    204: .same(proto: "ClickEvents_TRANSFER_CONSULT"),
    205: .same(proto: "ClickEvents_TRANSFER_CONSULT_CLOSE"),
    206: .same(proto: "ClickEvents_MENU_HIDE"),
    207: .same(proto: "ClickEvents_MENU_SHOW"),
    208: .same(proto: "ClickEvents_FILE_UPLOAD"),
    209: .same(proto: "ClickEvents_EMOJI"),
    210: .same(proto: "ClickEvents_SCREENSHOT"),
    211: .same(proto: "ClickEvents_SESSION_SEARCH"),
    212: .same(proto: "ClickEvents_SESSION_SEARCH_CLOSE"),
    213: .same(proto: "ClickEvents_SESSION_SEARCH_DATE"),
    214: .same(proto: "ClickEvents_SESSION_SEARCH_KEYWORDS"),
    215: .same(proto: "ClickEvents_SESSION_SEARCH_CONSULT"),
    216: .same(proto: "ClickEvents_SESSION_SEARCH_IMG"),
    217: .same(proto: "ClickEvents_SESSION_SEARCH_IMG_DOWNLOAD"),
    218: .same(proto: "ClickEvents_SESSION_SEARCH_IMG_COPY"),
    219: .same(proto: "ClickEvents_SESSION_SEARCH_VIDEO"),
    220: .same(proto: "ClickEvents_SESSION_SEARCH_VIDEO_DOWNLOAD"),
    221: .same(proto: "ClickEvents_SESSION_SEARCH_VIDEO_COPY"),
    222: .same(proto: "ClickEvents_SESSION_SEARCH_VIDEO_FULLSCREEN"),
    223: .same(proto: "ClickEvents_SESSION_SEARCH_VIDEO_BROWSER"),
    224: .same(proto: "ClickEvents_QUICK_REPLY_SHOW"),
    225: .same(proto: "ClickEvents_QUICK_REPLY_HIDE"),
    226: .same(proto: "ClickEvents_QUICK_REPLY_TOGGLE"),
    227: .same(proto: "ClickEvents_NOTE_ADD"),
    228: .same(proto: "ClickEvents_NOTE_DELETE"),
    229: .same(proto: "ClickEvents_NOTE_PAGINATION"),
    230: .same(proto: "ClickEvents_NOTE_CONTENT"),
    231: .same(proto: "ClickEvents_SEND"),
    232: .same(proto: "ClickEvents_VIDEO_DOWNLOAD"),
    233: .same(proto: "ClickEvents_IMG_ZOOM_IN"),
    234: .same(proto: "ClickEvents_VIDEO"),
    235: .same(proto: "ClickEvents_VIDEO_BROWSER"),
    236: .same(proto: "ClickEvents_VIDEO_FULLSCREEN"),
    300: .same(proto: "ClickEvents_USER_INFO_SHOW"),
    301: .same(proto: "ClickEvents_USER_INFO_HIDE"),
    302: .same(proto: "ClickEvents_RECHARGE_REFRESH"),
    303: .same(proto: "ClickEvents_COPY_RECHARGE_ID"),
    304: .same(proto: "ClickEvents_COPY_RECHARGE_OWNER"),
    305: .same(proto: "ClickEvents_COPY_RECHARGE_EMAIL"),
    306: .same(proto: "ClickEvents_COPY_RECHARGE_SOURCE"),
    307: .same(proto: "ClickEvents_COPY_WITHDRAW_ID"),
    308: .same(proto: "ClickEvents_COPY_WITHDRAW_OWNER"),
    309: .same(proto: "ClickEvents_USER_REPORT_SUBMIT"),
    310: .same(proto: "ClickEvents_SESSION_NOTE_OPEN"),
    311: .same(proto: "ClickEvents_SESSION_NOTE_CLOSE"),
    312: .same(proto: "ClickEvents_SESSION_NOTE_EDIT"),
    313: .same(proto: "ClickEvents_SESSION_NOTE_EDIT_SAVE"),
    314: .same(proto: "ClickEvents_SESSION_NOTE_DELETE"),
    315: .same(proto: "ClickEvents_SESSION_NOTE_SAVE"),
    316: .same(proto: "ClickEvents_SESSION_NOTE_CANCEL"),
    317: .same(proto: "ClickEvents_INQUIRY_SELECT"),
    318: .same(proto: "ClickEvents_INQUIRY_UNSELECT"),
    319: .same(proto: "ClickEvents_INQUIRY_SUBMIT"),
    320: .same(proto: "ClickEvents_INQUIRY_REFRESH"),
    321: .same(proto: "ClickEvents_INQUIRY_SHOW"),
    322: .same(proto: "ClickEvents_INQUIRY_CLOSE"),
  ]
}

extension Api_Core_ScrollEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ScrollEvents_MENU2_CHAT"),
    1: .same(proto: "ScrollEvents_MENU2_HISTORY"),
    100: .same(proto: "ScrollEvents_MENU3_CHAT"),
    101: .same(proto: "ScrollEvents_MENU3_HISTORY"),
    102: .same(proto: "ScrollEvents_TRANSFER_LIST"),
    200: .same(proto: "ScrollEvents_USER_INFO"),
    201: .same(proto: "ScrollEvents_INQUIRY"),
    202: .same(proto: "ScrollEvents_CHAT_NOTE"),
  ]
}

extension Api_Core_ActionEvents: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ActionEvents_HISTORY_SEARCH"),
    1: .same(proto: "ActionEvents_HISTORY_SEARCH_MSG"),
    100: .same(proto: "ActionEvents_SEARCH"),
    200: .same(proto: "ActionEvents_CONTEXT_MENU_COPY_MSG"),
    201: .same(proto: "ActionEvents_CONTEXT_MENU_COPY_IMG"),
    202: .same(proto: "ActionEvents_CONTEXT_MENU_COPY_IMG_LINK"),
    203: .same(proto: "ActionEvents_CONTEXT_MENU_COPY_VIDEO_LINK"),
    204: .same(proto: "ActionEvents_CONTEXT_MENU_COPY_EMOJI"),
    205: .same(proto: "ActionEvents_CONTEXT_MENU_REPLY_EMOJI"),
    206: .same(proto: "ActionEvents_CONTEXT_MENU_REPLY_IMG"),
    207: .same(proto: "ActionEvents_CONTEXT_MENU_REPLY_VIDEO"),
    208: .same(proto: "ActionEvents_CONTEXT_MENU_REPLY_MSG"),
    209: .same(proto: "ActionEvents_CONTEXT_MENU_NOTE_EMOJI"),
    210: .same(proto: "ActionEvents_CONTEXT_MENU_NOTE_IMG"),
    211: .same(proto: "ActionEvents_CONTEXT_MENU_NOTE_VIDEO"),
    212: .same(proto: "ActionEvents_CONTEXT_MENU_NOTE_MSG"),
    213: .same(proto: "ActionEvents_CONTEXT_MENU_EDIT_EMOJI"),
    214: .same(proto: "ActionEvents_CONTEXT_MENU_EDIT_IMG"),
    215: .same(proto: "ActionEvents_CONTEXT_MENU_EDIT_MSG"),
    216: .same(proto: "ActionEvents_CONTEXT_MENU_RECALL_MSG"),
    217: .same(proto: "ActionEvents_CONTEXT_MENU_RECALL_IMG"),
    218: .same(proto: "ActionEvents_CONTEXT_MENU_RECALL_VIDEO"),
    219: .same(proto: "ActionEvents_CONTEXT_MENU_RECALL_EMOJI"),
    220: .same(proto: "ActionEvents_CONTEXT_MENU_DOWNLOAD_IMG"),
    221: .same(proto: "ActionEvents_CONTEXT_MENU_DOWNLOAD_VIDEO"),
    222: .same(proto: "ActionEvents_TRANSFER_SEARCH"),
    223: .same(proto: "ActionEvents_SESSION_SEARCH_KEYWORDS"),
    224: .same(proto: "ActionEvents_QUICK_REPLY_SEARCH_KEYWORDS"),
    225: .same(proto: "ActionEvents_SESSION_INPUT"),
    300: .same(proto: "ActionEvents_TICKET_CONTENT_INPUT"),
    301: .same(proto: "ActionEvents_SESSION_NOTE_CONTENT_INPUT"),
  ]
}

extension Api_Core_EventCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_CATEGORY_CLICK"),
    1: .same(proto: "EVENT_CATEGORY_SCROLL"),
    2: .same(proto: "EVENT_CATEGORY_CLICK_SEND"),
  ]
}

extension Api_Core_EventTracking: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTracking"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "click"),
    4: .same(proto: "scroll"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sessionID) }()
      case 3: try {
        var v: Api_Core_ClickEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .click(v)
        }
      }()
      case 4: try {
        var v: Api_Core_ScrollEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .scroll(v)
        }
      }()
      case 5: try {
        var v: Api_Core_ActionEvents?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .action(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.sessionID != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionID, fieldNumber: 2)
    }
    switch self.event {
    case .click?: try {
      guard case .click(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case .scroll?: try {
      guard case .scroll(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case .action?: try {
      guard case .action(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTracking, rhs: Api_Core_EventTracking) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "worker_name"),
    3: .standard(proto: "worker_account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workerName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workerAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.workerName.isEmpty {
      try visitor.visitSingularStringField(value: self.workerName, fieldNumber: 2)
    }
    if !self.workerAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.workerAccount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingRequest, rhs: Api_Core_EventTrackingRequest) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.workerName != rhs.workerName {return false}
    if lhs.workerAccount != rhs.workerAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_ts"),
    2: .standard(proto: "end_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TimeRange, rhs: Api_Core_TimeRange) -> Bool {
    if lhs._startTs != rhs._startTs {return false}
    if lhs._endTs != rhs._endTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingDetailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .same(proto: "hourly"),
    3: .same(proto: "timeRange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hourly) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if self.hourly != false {
      try visitor.visitSingularBoolField(value: self.hourly, fieldNumber: 2)
    }
    try { if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDetailRequest, rhs: Api_Core_EventTrackingDetailRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.hourly != rhs.hourly {return false}
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingDetailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "total"),
    3: .standard(proto: "valid_session_count"),
    4: .standard(proto: "avg_resp_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.validSessionCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avgRespTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 2)
    }
    if self.validSessionCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.validSessionCount, fieldNumber: 3)
    }
    if !self.avgRespTime.isEmpty {
      try visitor.visitSingularStringField(value: self.avgRespTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDetailResponse, rhs: Api_Core_EventTrackingDetailResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.validSessionCount != rhs.validSessionCount {return false}
    if lhs.avgRespTime != rhs.avgRespTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDetailResponse.EventTrackingDetailItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api_Core_EventTrackingDetailResponse.protoMessageName + ".EventTrackingDetailItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "clicks"),
    3: .same(proto: "scrolls"),
    4: .same(proto: "sends"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hour) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.clicks) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.scrolls) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sends) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hour.isEmpty {
      try visitor.visitSingularStringField(value: self.hour, fieldNumber: 1)
    }
    if self.clicks != 0 {
      try visitor.visitSingularUInt32Field(value: self.clicks, fieldNumber: 2)
    }
    if self.scrolls != 0 {
      try visitor.visitSingularUInt32Field(value: self.scrolls, fieldNumber: 3)
    }
    if self.sends != 0 {
      try visitor.visitSingularUInt32Field(value: self.sends, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDetailResponse.EventTrackingDetailItem, rhs: Api_Core_EventTrackingDetailResponse.EventTrackingDetailItem) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.clicks != rhs.clicks {return false}
    if lhs.scrolls != rhs.scrolls {return false}
    if lhs.sends != rhs.sends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "event_category"),
    3: .same(proto: "cursor"),
    4: .same(proto: "reverse"),
    5: .same(proto: "limit"),
    6: .standard(proto: "time_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._eventCategory) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reverse) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try { if let v = self._eventCategory {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 3)
    }
    if self.reverse != false {
      try visitor.visitSingularBoolField(value: self.reverse, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 5)
    }
    try { if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingListRequest, rhs: Api_Core_EventTrackingListRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs._eventCategory != rhs._eventCategory {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.reverse != rhs.reverse {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingListResponse, rhs: Api_Core_EventTrackingListResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingListResponse.EventTrackingItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api_Core_EventTrackingListResponse.protoMessageName + ".EventTrackingItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "time_taken"),
    3: .standard(proto: "event_category"),
    4: .standard(proto: "event_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timeTaken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.eventCategory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 1)
    }
    if self.timeTaken != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTaken, fieldNumber: 2)
    }
    if !self.eventCategory.isEmpty {
      try visitor.visitSingularStringField(value: self.eventCategory, fieldNumber: 3)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingListResponse.EventTrackingItem, rhs: Api_Core_EventTrackingListResponse.EventTrackingItem) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timeTaken != rhs.timeTaken {return false}
    if lhs.eventCategory != rhs.eventCategory {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDailyStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingDailyStatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "worker_id"),
    3: .standard(proto: "worker_account"),
    4: .standard(proto: "worker_status"),
    5: .same(proto: "page"),
    6: .standard(proto: "page_size"),
    7: .standard(proto: "time_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.workerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workerAccount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._workerStatus) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 1)
    }
    if self.workerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.workerID, fieldNumber: 2)
    }
    if !self.workerAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.workerAccount, fieldNumber: 3)
    }
    try { if let v = self._workerStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 5)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 6)
    }
    try { if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDailyStatsRequest, rhs: Api_Core_EventTrackingDailyStatsRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.workerAccount != rhs.workerAccount {return false}
    if lhs._workerStatus != rhs._workerStatus {return false}
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDailyStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrackingDailyStatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDailyStatsResponse, rhs: Api_Core_EventTrackingDailyStatsResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_EventTrackingDailyStatsResponse.EventTrackingDailyStatsItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api_Core_EventTrackingDailyStatsResponse.protoMessageName + ".EventTrackingDailyStatsItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "worker_id"),
    3: .standard(proto: "last_alarm_trigger_time"),
    4: .standard(proto: "alarm_trigger_count"),
    5: .standard(proto: "alarm_duration"),
    6: .standard(proto: "click_count"),
    7: .standard(proto: "click_duration"),
    8: .standard(proto: "scroll_count"),
    9: .standard(proto: "scroll_duration"),
    10: .standard(proto: "send_count"),
    11: .standard(proto: "send_duration"),
    12: .standard(proto: "total_duration"),
    13: .standard(proto: "worker_status"),
    14: .standard(proto: "worker_acc"),
    15: .standard(proto: "avg_resp_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.workerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastAlarmTriggerTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.alarmTriggerCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.alarmDuration) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.clickCount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.clickDuration) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.scrollCount) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.scrollDuration) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.sendCount) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.sendDuration) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.totalDuration) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.workerStatus) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.workerAcc) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.avgRespTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.workerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.workerID, fieldNumber: 2)
    }
    if !self.lastAlarmTriggerTime.isEmpty {
      try visitor.visitSingularStringField(value: self.lastAlarmTriggerTime, fieldNumber: 3)
    }
    if self.alarmTriggerCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.alarmTriggerCount, fieldNumber: 4)
    }
    if self.alarmDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.alarmDuration, fieldNumber: 5)
    }
    if self.clickCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.clickCount, fieldNumber: 6)
    }
    if self.clickDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.clickDuration, fieldNumber: 7)
    }
    if self.scrollCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.scrollCount, fieldNumber: 8)
    }
    if self.scrollDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.scrollDuration, fieldNumber: 9)
    }
    if self.sendCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.sendCount, fieldNumber: 10)
    }
    if self.sendDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.sendDuration, fieldNumber: 11)
    }
    if self.totalDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalDuration, fieldNumber: 12)
    }
    if self.workerStatus != .workerOffline {
      try visitor.visitSingularEnumField(value: self.workerStatus, fieldNumber: 13)
    }
    if !self.workerAcc.isEmpty {
      try visitor.visitSingularStringField(value: self.workerAcc, fieldNumber: 14)
    }
    if !self.avgRespTime.isEmpty {
      try visitor.visitSingularStringField(value: self.avgRespTime, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_EventTrackingDailyStatsResponse.EventTrackingDailyStatsItem, rhs: Api_Core_EventTrackingDailyStatsResponse.EventTrackingDailyStatsItem) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.lastAlarmTriggerTime != rhs.lastAlarmTriggerTime {return false}
    if lhs.alarmTriggerCount != rhs.alarmTriggerCount {return false}
    if lhs.alarmDuration != rhs.alarmDuration {return false}
    if lhs.clickCount != rhs.clickCount {return false}
    if lhs.clickDuration != rhs.clickDuration {return false}
    if lhs.scrollCount != rhs.scrollCount {return false}
    if lhs.scrollDuration != rhs.scrollDuration {return false}
    if lhs.sendCount != rhs.sendCount {return false}
    if lhs.sendDuration != rhs.sendDuration {return false}
    if lhs.totalDuration != rhs.totalDuration {return false}
    if lhs.workerStatus != rhs.workerStatus {return false}
    if lhs.workerAcc != rhs.workerAcc {return false}
    if lhs.avgRespTime != rhs.avgRespTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
